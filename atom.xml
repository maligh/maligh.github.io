<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>记录学习中的点滴,努力打怪升级-MaLi</title>
  <subtitle>记录学习中的点滴</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://superma.me/"/>
  <updated>2018-03-03T06:34:49.970Z</updated>
  <id>http://superma.me/</id>
  
  <author>
    <name>Mali</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS开发中的11种锁以及性能对比</title>
    <link href="http://superma.me/2018/03/03/iOS%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%8411%E7%A7%8D%E9%94%81%E4%BB%A5%E5%8F%8A%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/"/>
    <id>http://superma.me/2018/03/03/iOS开发中的11种锁以及性能对比/</id>
    <published>2018-03-03T06:30:35.000Z</published>
    <updated>2018-03-03T06:34:49.970Z</updated>
    
    <content type="html"><![CDATA[<p>在平时开发中我们经常会使用多线程，多线程为我们带来了很大便利，也提高了程序的执行效率，但同时也带来了<code>Data race</code>。<a id="more"></a><code>Data race</code>的定义很简单：当至少有两个线程同时访问同一个变量，而且至少其中有一个是写操作时，就发生了<code>Data race</code>。所以这是就要利用一些同步机制来确保数据的准确性，锁就是同步机制中的一种。</p>
<h2 id="怎么检测项目中的Data-race？"><a href="#怎么检测项目中的Data-race？" class="headerlink" title="怎么检测项目中的Data race？"></a>怎么检测项目中的<code>Data race</code>？</h2><p><img src="http://upload-images.jianshu.io/upload_images/1457495-7da10e7cbd400978.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>只需要在设置中勾选<code>Thread Sanitizer</code> 即可，顺便可以勾选<code>Pause on issues</code> 就可以断点到相应的代码。<br>更多延伸内容请参考Peak君的<a href="http://mrpeak.cn/blog/thread-sanitizer/" target="_blank" rel="external">如何用Xcode8解决多线程问题</a>和<a href="http://www.mrpeak.cn/blog/ios-thread-safety/" target="_blank" rel="external">iOS多线程到底不安全在哪里？</a></p>
<p>下面就进入正题简单聊一聊iOS中的锁，以及相关的内容（由于本人能力有限，文中难免有一些遗漏或者错误，请各位看官不吝赐教！谢谢！🙏)</p>
<h2 id="简单的性能测试"><a href="#简单的性能测试" class="headerlink" title="简单的性能测试"></a>简单的性能测试</h2><p>下图是我针对iOS中的锁自己测试得出的，图中数字代表每次加解锁需要消耗的时间，单位为ns。<a href="https://github.com/maligh/ML-Objective-C-Demo/tree/master/LockPerformance" target="_blank" rel="external">代码在这里</a>，代码参考自YY大神的<a href="https://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/" target="_blank" rel="external">不再安全的 OSSpinLock</a>，基本跟YY大神的图差不多😉，YY大神的单位是μs，应该是1000次的，或者写错了吧~<br><img src="http://upload-images.jianshu.io/upload_images/1457495-4151d1dc7f68827e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="LockPerformance.jpg"></p>
<ul>
<li>注：运行手机： iphone6s plus ，系统版本：11.2.2，Xcode9.2；数字的单位为ns（得出的具体数值是跑了多次取的均值）。</li>
</ul>
<p>值得注意的是：1.这个数字仅仅代表每次加解锁的耗时，并不能全方面的代表性能。2.不同的机型和系统，不同的循环次数可能结果会略微有些差异。<br>但是还是可以看出<code>@synchronized:</code>是表现最差的。</p>
<p><strong>在具体说这些锁之前，先来说几个概念定义：</strong>(参考<a href="https://www.wikipedia.org/" target="_blank" rel="external">维基百科</a>)</p>
<ol>
<li><strong>临界区：</strong>指的是一块对公共资源进行访问的代码，并非一种机制或是算法。</li>
<li><p><strong>自旋锁：</strong>是用于多线程同步的一种锁，线程反复检查锁变量是否可用。由于线程在这一过程中保持执行，因此是一种<code>忙等待</code>。一旦获取了自旋锁，线程会一直保持该锁，直至显式释放自旋锁。 自旋锁避免了进程上下文的调度开销，因此对于线程只会阻塞很短时间的场合是有效的。</p>
</li>
<li><p><strong>互斥锁（Mutex）：</strong>是一种用于多线程编程中，防止两条线程同时对同一公共资源（比如全局变量）进行读写的机制。该目的通过将代码切片成一个一个的临界区而达成。</p>
</li>
<li><p><strong>读写锁：</strong>是计算机程序的并发控制的一种同步机制，也称“共享-互斥锁”、多读者-单写者锁) 用于解决多线程对公共资源读写问题。读操作可并发重入，写操作是互斥的。 读写锁通常用互斥锁、条件变量、信号量实现。</p>
</li>
<li><p><strong>信号量（semaphore）：</strong>是一种更高级的同步机制，<code>互斥锁</code>可以说是semaphore在仅取值0/1时的特例。<code>信号量</code>可以有更多的取值空间，用来实现更加复杂的同步，而不单单是线程间互斥。</p>
</li>
<li><p><strong>条件锁：</strong>就是条件变量，当进程的某些资源要求不满足时就进入休眠，也就是锁住了。当资源被分配到了，条件锁打开，进程继续运行。</p>
</li>
</ol>
<h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h2><p><strong>1.NSLock：</strong>是Foundation框架中以对象形式暴露给开发者的一种锁，（Foundation框架同时提供了<code>NSConditionLock</code>，<code>NSRecursiveLock</code>，<code>NSCondition</code>）<code>NSLock</code>定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">@protocol NSLocking</div><div class="line"></div><div class="line">- (void)lock;</div><div class="line">- (void)unlock;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@interface NSLock : NSObject &lt;NSLocking&gt; &#123;</div><div class="line">@private</div><div class="line">    void *_priv;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (BOOL)tryLock;</div><div class="line">- (BOOL)lockBeforeDate:(NSDate *)limit;</div><div class="line"></div><div class="line">@property (nullable, copy) NSString *name API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0));</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p>tryLock 和 lock 方法都会请求加锁，唯一不同的是trylock在没有获得锁的时候可以继续做一些任务和处理。lockBeforeDate方法也比较简单，就是在limit时间点之前获得锁，没有拿到返回NO。<br><strong>实际项目中：</strong>NSLock在<a href="https://github.com/AFNetworking/AFNetworking/blob/master/AFNetworking/AFURLSessionManager.m" target="_blank" rel="external">AFNetworking的AFURLSessionManager.m</a>中应用如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">- (instancetype)initWithSessionConfiguration:(NSURLSessionConfiguration *)configuration &#123;</div><div class="line">    ...</div><div class="line">    self.lock = [[NSLock alloc] init];</div><div class="line">    self.lock.name = AFURLSessionManagerLockName;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line">- (void)setDelegate:(AFURLSessionManagerTaskDelegate *)delegate</div><div class="line">            forTask:(NSURLSessionTask *)task</div><div class="line">&#123;</div><div class="line">    ...</div><div class="line">    [self.lock lock];</div><div class="line">    self.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)] = delegate;</div><div class="line">    [delegate setupProgressForTask:task];</div><div class="line">    [self addNotificationObserverForTask:task];</div><div class="line">    [self.lock unlock];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>2.pthread_mutex：</strong><br><strong>实际项目中：</strong> 在<a href="https://github.com/ibireme/YYKit/blob/3869686e0e560db0b27a7140188fad771e271508/YYKit/Cache/YYMemoryCache.m" target="_blank" rel="external">YYKit的YYMemoryCach中可以看到</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">- (instancetype)init &#123;</div><div class="line">    ...</div><div class="line">    pthread_mutex_init(&amp;_lock, NULL);</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line">- (void)_trimToCost:(NSUInteger)costLimit &#123;</div><div class="line">    BOOL finish = NO;</div><div class="line">    pthread_mutex_lock(&amp;_lock);</div><div class="line">    if (costLimit == 0) &#123;</div><div class="line">        [_lru removeAll];</div><div class="line">        finish = YES;</div><div class="line">    &#125; else if (_lru-&gt;_totalCost &lt;= costLimit) &#123;</div><div class="line">        finish = YES;</div><div class="line">    &#125;</div><div class="line">    pthread_mutex_unlock(&amp;_lock);</div><div class="line">    if (finish) return;</div><div class="line">    </div><div class="line">    NSMutableArray *holder = [NSMutableArray new];</div><div class="line">    while (!finish) &#123;</div><div class="line">        if (pthread_mutex_trylock(&amp;_lock) == 0) &#123;</div><div class="line">            if (_lru-&gt;_totalCost &gt; costLimit) &#123;</div><div class="line">                _YYLinkedMapNode *node = [_lru removeTailNode];</div><div class="line">                if (node) [holder addObject:node];</div><div class="line">            &#125; else &#123;</div><div class="line">                finish = YES;</div><div class="line">            &#125;</div><div class="line">            pthread_mutex_unlock(&amp;_lock);</div><div class="line">        &#125; else &#123;</div><div class="line">            usleep(10 * 1000); //10 ms</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">   ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>3.@synchronized:</strong><br><strong>实际项目中：</strong>AFNetworking中 isNetworkActivityOccurring属性的getter方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (BOOL)isNetworkActivityOccurring &#123;</div><div class="line">    @synchronized(self) &#123;</div><div class="line">        return self.activityCount &gt; 0;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>关于 @synchronized推荐扩展阅读  <a href="http://yulingtianxia.com/blog/2015/11/01/More-than-you-want-to-know-about-synchronized/" target="_blank" rel="external">关于 @synchronized，这儿比你想知道的还要多</a></p>
<h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p><strong>1.OSSpinLock:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">OSSpinLock lock = OS_SPINLOCK_INIT;</div><div class="line">OSSpinLockLock(&amp;lock);</div><div class="line">...</div><div class="line">OSSpinLockUnlock(&amp;lock);</div></pre></td></tr></table></figure></p>
<p>上面是OSSpinLock使用方式，编译会报警告，已经废弃了，OSSpinLock大家也已经不再用它了，因为它在某一些场景下已经不安全了，可以参考 YY大神的<a href="https://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/" target="_blank" rel="external">不再安全的 OSSpinLock</a>，在Protocol Buffers项目中你可以看到这样的注释，大家已经用新的方案替换了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// NOTE: OSSpinLock may seem like a good fit here but Apple engineers have</div><div class="line"> // pointed out that they are vulnerable to live locking on iOS in cases of</div><div class="line"> // priority inversion:</div><div class="line"> //   http://mjtsai.com/blog/2015/12/16/osspinlock-is-unsafe/</div><div class="line"> //   https://lists.swift.org/pipermail/swift-dev/Week-of-Mon-20151214/000372.html</div></pre></td></tr></table></figure></p>
<p><strong>2.os_unfair_lock:</strong><br>os_unfair_lock 是苹果官方推荐的替换OSSpinLock的方案，但是它在iOS10.0以上的系统才可以调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">os_unfair_lock_t unfairLock;</div><div class="line">unfairLock = &amp;(OS_UNFAIR_LOCK_INIT);</div><div class="line">os_unfair_lock_lock(unfairLock);</div><div class="line">os_unfair_lock_unlock(unfairLock);</div></pre></td></tr></table></figure></p>
<h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><p>上文有说到，读写锁又称共享-互斥锁，<br><strong>pthread_rwlock：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//加读锁</div><div class="line">pthread_rwlock_rdlock(&amp;rwlock);</div><div class="line">//解锁</div><div class="line">pthread_rwlock_unlock(&amp;rwlock);</div><div class="line">//加写锁</div><div class="line">pthread_rwlock_wrlock(&amp;rwlock);</div><div class="line">//解锁</div><div class="line">pthread_rwlock_unlock(&amp;rwlock);</div></pre></td></tr></table></figure></p>
<h2 id="递归锁"><a href="#递归锁" class="headerlink" title="递归锁"></a>递归锁</h2><p>递归锁有一个特点，就是同一个线程可以加锁N次而不会引发死锁。<br><strong>1.NSRecursiveLock:</strong><br>NSRecursiveLock在<a href="https://github.com/ibireme/YYKit/blob/4e1bd1cfcdb3331244b219cbd37cc9b1ccb62b7a/YYKit/Image/YYWebImageOperation.m" target="_blank" rel="external">YYKit中YYWebImageOperation.m</a>中有用到：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">_lock = [NSRecursiveLock new];</div><div class="line">- (void)dealloc &#123;</div><div class="line">    [_lock lock];</div><div class="line">    ...</div><div class="line">    ...</div><div class="line">    [_lock unlock];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>2.pthread_mutex(recursive):</strong><br>pthread_mutex锁也支持递归，只需要设置PTHREAD_MUTEX_RECURSIVE即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">pthread_mutex_t lock;</div><div class="line">pthread_mutexattr_t attr;</div><div class="line">pthread_mutexattr_init(&amp;attr);</div><div class="line">pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_RECURSIVE);</div><div class="line">pthread_mutex_init(&amp;lock, &amp;attr);</div><div class="line">pthread_mutexattr_destroy(&amp;attr);</div><div class="line">pthread_mutex_lock(&amp;lock);</div><div class="line">pthread_mutex_unlock(&amp;lock);</div></pre></td></tr></table></figure></p>
<h2 id="条件锁"><a href="#条件锁" class="headerlink" title="条件锁"></a>条件锁</h2><p><strong>1. NSCondition:</strong><br><strong>定义：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@interface NSCondition : NSObject &lt;NSLocking&gt; &#123;</div><div class="line">@private</div><div class="line">    void *_priv;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)wait;</div><div class="line">- (BOOL)waitUntilDate:(NSDate *)limit;</div><div class="line">- (void)signal;</div><div class="line">- (void)broadcast;</div></pre></td></tr></table></figure></p>
<p>遵循NSLocking协议，使用的时候同样是lock,unlock加解锁，wait是傻等，waitUntilDate:方法是等一会，都会阻塞掉线程，signal是唤起一个在等待的线程，broadcast是广播全部唤起。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">NSCondition *lock = [[NSCondition alloc] init];</div><div class="line">//Son 线程</div><div class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class="line">    [lock lock];</div><div class="line">    while (No Money) &#123;</div><div class="line">        [lock wait];</div><div class="line">    &#125;</div><div class="line">    NSLog(@&quot;The money has been used up.&quot;);</div><div class="line">    [lock unlock];</div><div class="line">&#125;);</div><div class="line">    </div><div class="line"> //Father线程</div><div class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class="line">    [lock lock];</div><div class="line">    NSLog(@&quot;Work hard to make money.&quot;);</div><div class="line">    [lock signal];</div><div class="line">    [lock unlock];</div><div class="line"> &#125;);</div></pre></td></tr></table></figure></p>
<p><strong>2.NSConditionLock:</strong><br><strong>定义：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">@interface NSConditionLock : NSObject &lt;NSLocking&gt; &#123;</div><div class="line">@private</div><div class="line">    void *_priv;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (instancetype)initWithCondition:(NSInteger)condition NS_DESIGNATED_INITIALIZER;</div><div class="line"></div><div class="line">@property (readonly) NSInteger condition;</div><div class="line">- (void)lockWhenCondition:(NSInteger)condition;</div><div class="line">- (BOOL)tryLock;</div><div class="line">- (BOOL)tryLockWhenCondition:(NSInteger)condition;</div><div class="line">- (void)unlockWithCondition:(NSInteger)condition;</div><div class="line">- (BOOL)lockBeforeDate:(NSDate *)limit;</div><div class="line">- (BOOL)lockWhenCondition:(NSInteger)condition beforeDate:(NSDate *)limit;</div></pre></td></tr></table></figure></p>
<p>很简单，方法很清晰，基本同上。</p>
<h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p><strong>dispatch_semaphore:</strong><br>dispatch_semaphore在YYKit中的<a href="https://github.com/ibireme/YYKit/blob/3869686e0e560db0b27a7140188fad771e271508/YYKit/Utility/YYThreadSafeArray.m" target="_blank" rel="external">YYThreadSafeArray.m</a>有所应用，YY大神有这样一句注释：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@discussion Generally, access performance is lower than NSMutableArray, </div><div class="line"> but higher than using @synchronized, NSLock, or pthread_mutex_t.</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#define LOCK(...) dispatch_semaphore_wait(_lock, DISPATCH_TIME_FOREVER); \</div><div class="line">__VA_ARGS__; \</div><div class="line">dispatch_semaphore_signal(_lock);</div></pre></td></tr></table></figure>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>其实本文写的都是一些再基础不过的内容，在平时阅读一些开源项目的时候经常会遇到一些保持线程同步的方式，因为场景不同可能选型不同，这篇就做一下简单的记录吧~我相信读完这篇你应该能根据不同场景选择合适的锁了吧、能够道出<code>自旋锁</code>和<code>互斥锁</code>的区别了吧。</p>
<h2 id="最后："><a href="#最后：" class="headerlink" title="最后："></a>最后：</h2><p>由于本人能力有限，文中难免有一些遗漏或者错误，请各位看官不吝赐教！谢谢！同时有任何关于锁相关的疑问可以疯狂留言，一起交流，一起进步~🙏 祝大家每天都能进步一点点~</p>
<h2 id="扩展阅读："><a href="#扩展阅读：" class="headerlink" title="扩展阅读："></a>扩展阅读：</h2><ol>
<li><a href="https://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/" target="_blank" rel="external">不再安全的 OSSpinLock</a>🔥🔥</li>
<li><a href="https://juejin.im/post/57f6e9f85bbb50005b126e5f" target="_blank" rel="external">深入理解 iOS 开发中的锁</a>🔥🔥</li>
<li><a href="http://yulingtianxia.com/blog/2015/11/01/More-than-you-want-to-know-about-synchronized/" target="_blank" rel="external">关于 @synchronized，这儿比你想知道的还要多</a>🔥🔥🔥</li>
<li><a href="https://casatwy.com/pthreadde-ge-chong-tong-bu-ji-zhi.html" target="_blank" rel="external">pthread的各种同步机制- Casa Taloyum</a>🔥🔥</li>
<li><a href="https://developer.apple.com/library/prerelease/content/documentation/Cocoa/Conceptual/Multithreading/Introduction/Introduction.html#//apple_ref/doc/uid/10000057" target="_blank" rel="external">Threading Programming Guide</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在平时开发中我们经常会使用多线程，多线程为我们带来了很大便利，也提高了程序的执行效率，但同时也带来了&lt;code&gt;Data race&lt;/code&gt;。
    
    </summary>
    
      <category term="Objective-C" scheme="http://superma.me/all-categories/Objective-C/"/>
    
    
      <category term="多线程" scheme="http://superma.me/all-tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>提升iOS开发效率的一些keys</title>
    <link href="http://superma.me/2018/02/04/%E6%8F%90%E5%8D%87iOS%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E7%9A%84%E4%B8%80%E4%BA%9Bkeys/"/>
    <id>http://superma.me/2018/02/04/提升iOS开发效率的一些keys/</id>
    <published>2018-02-04T09:20:06.000Z</published>
    <updated>2018-02-27T16:13:12.020Z</updated>
    
    <content type="html"><![CDATA[<p>首先题目写的有点大，这篇文章只是分享一下我平时用到的一些快捷键和习惯，希望能对大家平时的开发效率有所帮助。<a id="more"></a></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1457495-082a6ea037b27c99.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h2 id="至于为什么要写？"><a href="#至于为什么要写？" class="headerlink" title="至于为什么要写？"></a>至于为什么要写？</h2><p> 原因有几点：</p>
<ol>
<li>工作中我发现有些iOS小伙伴平时开发的时候，比如在快速打开一个类文件的时候，还在项目目录里面一层一层的找，等等，希望本文能提升他们的开发幸福感。</li>
<li>我自认为我知道的快捷键还蛮多的，但是还是从同事那里学到了几个实用的🤓，这篇文章就当做记录分享自己平时开发的一些小技巧吧，大家看完有什么更好的tip 可以留言分享给我，相当于抛砖引玉吧，我会持续更新的~希望大家都能做一个<code>懒惰的程序员</code>（文末有我对<code>懒惰程序员</code>的定义）。</li>
</ol>
<h2 id="鼠标-和-触摸板"><a href="#鼠标-和-触摸板" class="headerlink" title="鼠标 和 触摸板"></a>鼠标 和 触摸板</h2><p>如果你用的iMac 大部分用的是苹果的鼠标，苹果的鼠标是可以设置智能手势的，这些在系统偏好里面都有教程和设置，大家可以去看一下，每每看到同事还在把iMac的鼠标当做windows的来用，我真想说这个鼠标贵是有道理的🙃。<br>鼠标：1. 一个手指右滑返回，在Xcode 中就不用每次都去点击返回上一个类了。2. 两个手指左\右滑切换桌面，MacOS的多桌面挺好的，可以一个放UI，一个放代码，一个放接口文档等等。3. 两个手指轻点，相当于F3上面的快捷键Miss Control，很方便。<br>触摸板：跟鼠标基本一样，切换桌面是三个手指左\右滑，Miss Control 是三个手指向上滑。 </p>
<p>好了，废话不多说，直接进入关键的吧，我默认用快捷键的使用频次排序吧，希望大家都能动手尝试下。</p>
<h2 id="Xcode-中"><a href="#Xcode-中" class="headerlink" title="Xcode 中"></a>Xcode 中</h2><ol>
<li><code>Shift + Command + O</code> 弹出快速查找文件窗口（这个是字母O，Markdown O之后很像数字0 ），<code>Shift +Commond + 0</code> 是快速打开官方文档的快捷键。</li>
<li><code>Shift + Comand + j</code> 定位到文件所在目录，经常配合上面那条快捷键。</li>
<li><code>Control + Command + 上\下</code> 切换 <code>.m</code> 和<code>.h</code>。</li>
<li><code>Command + t</code> 新建一个Tab，这个很实用，我平时一般都会建3，4个Tab，关闭Tab 可以用 <code>Command + w</code>。</li>
<li>如果你不习惯开多个Tab，习惯开多个Xcode窗口，可以用Command + ` 来互相切换。</li>
<li><code>Control + Command + e</code> 可以批量修改光标所在位置的变量，像这样<img src="http://upload-images.jianshu.io/upload_images/1457495-905681620219f616.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li>
<li><code>Shift + Command + f</code> 打开全局搜索，当然你可以连续按住<code>Command</code>键连续按两次 4，也会聚焦到全局搜索，全局搜索这里要说一下，搜索Xcode 不仅仅是支持text匹配，最常用的可以加个 <code>Any</code> 正则，就可以搜出如图中的这种，等等。<br><img src="http://upload-images.jianshu.io/upload_images/1457495-e271cead8fed657a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li>
<li><code>Command + f</code> 在类中搜索 ，<code>enter</code> 匹配下一个 <code>Shift + enter</code> 匹配上一个。</li>
<li><code>Command + 上\下\左\右</code>  光标切换到类首，类尾，行首，行尾。</li>
<li><code>alt + 左\右</code> 光标左右移动一个单词。 </li>
<li><code>Command + delete</code> 删除光标到行首的内容，同理<code>alt + delete</code> 删除光标前的一个单词，另外可以先切换到到行尾 用<code>Command + delete</code>删除一整行内容。</li>
<li>同理 <code>Command + Shift</code> 和 <code>Command + alt</code>加方向键就可以选中一整行或者多行了。</li>
<li>选中一段代码 <code>Control + i</code> 会自动缩进。</li>
<li><code>Command + \</code> 当前行加断点，<code>alt + Command + \</code>，新建一个<code>symbolic breakpoint</code>。</li>
<li><code>Command + n</code>新建文件 ，<code>Shift + Command + n</code> 新建工程</li>
<li><code>alt + Command + 左\右</code>  折叠\显示当前块，<code>Shift + alt + Command + 左\右</code> 折叠\显示当前文件中的块。</li>
<li><code>alt + Command + [</code> 上移，如果没有选中，默认上移当前行，<code>alt + Command + ]</code> 下移。</li>
<li><code>Command + ]</code> 向右缩进，支持多行，<code>Command + [</code> 向左缩进。</li>
<li><code>Shift + Command + k</code> product 清理，<code>Command + r</code> Run，<code>Command + b</code> 编译。</li>
<li>还有一个重要的快捷键，☝️，<code>Control + Command + p</code> 快捷导入，像这样，<img src="http://upload-images.jianshu.io/upload_images/1457495-710fa3971957a3a1.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>很酷吧，需要导入一个工具才可以实现，<a href="https://github.com/markohlebar/Import" target="_blank" rel="external">可以点击这里</a>，Xcode 9 以前用过类似的插件也可以实现这个功能，之前还用<a href="http://mrpeak.cn/" target="_blank" rel="external">Peak君</a>的<a href="https://github.com/music4kid/FastStub-Xcode" target="_blank" rel="external">FastStub-Xcode</a>也挺爽的。</li>
</ol>
<h2 id="Xcode-窗体相关"><a href="#Xcode-窗体相关" class="headerlink" title="Xcode 窗体相关"></a>Xcode 窗体相关</h2><ol>
<li><code>Shift + Command + Y</code> 隐藏 \ 显示 console 区，但是我建议显示console区 用 <code>Shift + Command + C</code>，会直接聚焦效果。</li>
<li><code>Command + k</code> console清屏。</li>
<li><code>Control + 1</code> 这个应该很多工程师都没用过🌚，当然点击小图标也可以。<img src="http://upload-images.jianshu.io/upload_images/1457495-a09c8500ed329e93.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>如图可以看到所有调用者，导入的文件，被那些导入等等相关依赖。还可以找到最近打开的文件，Recent Files </li>
<li><code>Control + 6</code> 查看当前类的方法列表，这里建议用 <code>pragma mark</code> 来合理分块，<a href="https://www.jianshu.com/p/bbb0b57eb168" target="_blank" rel="external">相关扩展阅读可以看这里的代码规范建议</a></li>
<li><code>Command + 1,2,3,4,5,6,7,8,9</code> 切换左边窗体，<code>Command + 0</code> 显示 \ 隐藏左边窗体。</li>
<li><code>alt + Command + 0</code> 显示 \ 隐藏右边窗体，同理<code>alt + Command + 1,2</code>等也可以切换</li>
<li><code>Command + ,</code> 弹出 Perferences ,可以用 <code>Command + w</code> 隐藏</li>
</ol>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ol>
<li>还有一个多行编辑，有的时候也会用到，需要借助Sublime Text, 快捷键是 <code>Shift + Command + L</code>，退出多行编辑也是<code>Shift + Command + L</code><br><img src="http://upload-images.jianshu.io/upload_images/1457495-4b1e05f2c78c0d22.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""> </li>
<li><code>Shift + Command +3</code> 全屏截图，<code>Shift + Command + 4</code> 自选区域截图，<code>Shift + Command + 4 + 空格</code> 截图某一个窗体。</li>
<li><code>Command + F3</code> 快捷查看桌面。</li>
<li><code>Control + Command + 空格</code> 弹出表情输入框。</li>
</ol>
<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p>推荐大家安装 <code>CheatSheet</code>，之后长按Command 就可以查看所有的快捷键了。<br>题外：在推荐给大家一个应用，<a href="http://www.noiz.io/" target="_blank" rel="external">Noizio </a>，环境噪音模拟工具，可以模拟在咖啡馆，可以模拟在海边等等。</p>
<h2 id="关于懒惰程序员"><a href="#关于懒惰程序员" class="headerlink" title="关于懒惰程序员"></a>关于懒惰程序员</h2><p>懒惰对于程序员其实是一种夸奖，这里的懒惰并不是常规意义上的懒惰，也许你听过<code>懒惰是程序员的第一美德</code>。懒惰会让程序员想到一些更好的方案去解决手上的问题，往往的结果都是节省了很多体力劳动，以及达到同样的需求用的是最优雅最便捷的方式。<br>举一个实际例子就是，我们最近项目引入了国际化，大家都知道翻译真的是一个体力活，我身边的同事用Python写了一个脚本，可以自动检测需要翻译的文字，自动写到相应的Localization文件以及文字代码所在的位置，大大节省了体力劳动，这就是优秀的懒惰美德。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>如果大家有什么觉得好的快捷键或者是一些提升效率的idea，可以留言分享给我，也让我有一些好习惯补充，同时我也会更新本文，谢谢！希望大家都能成为一个懒惰的程序员，节省下来的时间去喝杯咖啡不好吗？🤓</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先题目写的有点大，这篇文章只是分享一下我平时用到的一些快捷键和习惯，希望能对大家平时的开发效率有所帮助。
    
    </summary>
    
      <category term="Objective-C" scheme="http://superma.me/all-categories/Objective-C/"/>
    
    
      <category term="效率" scheme="http://superma.me/all-tags/%E6%95%88%E7%8E%87/"/>
    
  </entry>
  
  <entry>
    <title>2017年终总结</title>
    <link href="http://superma.me/2017/12/31/2017%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    <id>http://superma.me/2017/12/31/2017年终总结/</id>
    <published>2017-12-31T14:31:18.000Z</published>
    <updated>2017-12-31T15:06:22.778Z</updated>
    
    <content type="html"><![CDATA[<p>转眼2017年走到了尾声，之前很少有写<code>年终总结</code>，如今已到了奔三的年纪，肩上的责任也越来越‘丰富’，每年做个总结，尽量避免每年‘瞎忙’吧。<a id="more"></a></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1457495-7dd518bf11850849.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h2 id="LeaderShip"><a href="#LeaderShip" class="headerlink" title="LeaderShip"></a>LeaderShip</h2><p>其实在17年年初的时候有给自己定过努力的方向，就是尽量提升LeaderShip，<a href="http://www.cocoachina.com/programmer/20161229/18469.html" target="_blank" rel="external">关于LeaderShip可以简单看一下这篇文章</a>，虽然这篇文章的观点我并不完全认同，但大部分还是说的还是有些道理的。我眼中的LeaderShip :</p>
<ol>
<li><p>被需要：团队或身边中大多数人在做比较关键的决定时，或者在遇到比较棘手的问题的时候往往都会想到你，找到你一起商议。</p>
</li>
<li><p>救火能力：当身边的人都在问“这个问题怎么办”的时候，你应该总是能站出来帮同事顺利解决掉麻烦，能每次成功救火（能不能每次都顺利救火，也就决定了你LeaderShip的等级）</p>
</li>
<li><p>更多的承担：即使项目中很多不是你份内的任务，也应该带着一颗学习的心态多去了解，去思考如果是你来做会有什么不同，或者有什么建设性意见可以跟同事提一提或者探讨。（建设性意见的多少，或者防火次数的多少也就决定了你LeaderShip的等级）</p>
</li>
<li><p>更多的分享：尽量把一些好的方法、技术、技能点、工具分享给身边的人。情绪会传染，这个大家应该都知道，其实分享精神也同样会传染的，当你分享的东西让大家受益之后，久而久之，别人也都很愿意分享自己的“金刚钻”给你，这样的良性循环能大大提升团队以及自己的成长速度。（炫技的除外）</p>
</li>
</ol>
<p>根据以上几点，回顾自己17年，感觉还差的很多，但进步还是有的，18年应该继续朝这个方向努力。需要明显改善的就是对错误的记录，避免犯同样的错误，再遇到同样的错误也能快速准确的解决掉，同时可以加上分享，让更多的人受益。</p>
<hr>
<h2 id="读过的书"><a href="#读过的书" class="headerlink" title="读过的书"></a>读过的书</h2><p><img src="http://upload-images.jianshu.io/upload_images/1457495-ff2a7c19ca209852.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ReadList.jpg"></p>
<p>今年还是读了不少书的，以上就是今年读过的一些书籍，从左到右（精读到泛读），读完的还是有11本，除此之外还有一本《软技能-代码之外的生存指南》还在读，大部分都是技术书籍，除了技术讲解的书籍之外的一些书都在传递教授一些思想，我不否认我不认同全部，但是能在一本书中得到一点或者几点启迪我还是很满足的！我很赞同<code>何帆</code>老师说的，类似书要“为我所用”才有价值（不记得原话了）</p>
<p>除了读纸质的数据还读了一些电子书：</p>
<ol>
<li><a href="https://github.com/numbbbbb/the-swift-programming-language-in-chinese" target="_blank" rel="external">《The Swift Programming Language 中文版》</a>只陆陆续续读了一部分，也照着敲了一部分，惭愧惭愧啊😂！</li>
<li><a href="https://xiaozhuanlan.com/wwdc17" target="_blank" rel="external">《iOS成长之路系列》</a>目前一共有3期都买了，只看了一部分自己感兴趣的文章，大佬们的合集，有时间还是要好好拜读。</li>
<li>最近过了一遍 <a href="https://juejin.im/user/57638ad8207703006b06e3ef" target="_blank" rel="external">bestswifter</a> 的 《Python 指北》还是挺有帮助的。</li>
<li>还买了一本 <a href="https://www.qingdan.us/product/25" target="_blank" rel="external">《iOS监控编程》</a> 这本读完了🤥（没读完）</li>
</ol>
<hr>
<h2 id="内容付费"><a href="#内容付费" class="headerlink" title="内容付费"></a>内容付费</h2><p>去年到今年内容付费火了，我知道和接触的有不少内容付费的事物，有很多还是蛮有帮助的。我自己参与的内容付费也成功收获了1W+的粉丝，虽然不是技术的，但多少也带来了一点微薄收入吧。<br>这一年自己学习过的并且觉得有帮助的一些Project List记录 :</p>
<ol>
<li><a href="https://casatwy.com/" target="_blank" rel="external">Casa</a> 的 <a href="http://m.quzhiboapp.com/?#!/intro/376" target="_blank" rel="external">闲话 iOS 应用架构</a>，Casa 讲的真的好，他文章也是读了很多遍，尤其是 <a href="https://casatwy.com/iosying-yong-jia-gou-tan-kai-pian.html" target="_blank" rel="external">架构这个系列</a> 目前还没有太多的实践，18年要补上来🤨</li>
<li>孙源的 <a href="http://m.quzhiboapp.com/?#!/intro/115" target="_blank" rel="external">iOS 面试小灶直播 - 简历、面试题、进阶</a>，关于面试的很多观点都觉得很赞👍</li>
<li>喵神的<a href="http://m.quzhiboapp.com/#!/intro/391" target="_blank" rel="external">现场编程 - 用 Swift 创建命令行工具 fengniao-cli Part 1</a>，很可惜只全程观看了part1，因为实在是跟不上喵神。但是看了喵神的现场编程全过程，也理解了他说的那句：不必太崇拜大牛，很多大牛也是面向google，面向github编程的！</li>
<li>巧神的 <a href="http://m.quzhiboapp.com/?#!/intro/406" target="_blank" rel="external">你所不知道的硅谷 &amp; 旅游攻略</a> 看了巧神的硅谷之行之后真的特别想去硅谷，但是很尴尬，一个是经济的限制，另外一个是人脉的局限，那边根本没有熟人和同事啊！！😭 但还是开阔了一些视野，也了解到了华人工程师和印度工程师的一些差异，也跟国内的IT氛围有很大关系吧。说到这里，聊点题外话，很巧，我女朋友也是一枚程序媛，我们是大学同学，在她工作经历中我能感到一些公司对女性程序媛的歧视吧，很难让我不扩大到大部分。（注：她是一枚Android程序媛，目前工资比我高🤪）</li>
<li><a href="https://juejin.im/user/5656f11760b28da566412f03" target="_blank" rel="external">joy</a>的 <a href="http://m.quzhiboapp.com/?#!/intro/392" target="_blank" rel="external">从 iOS 角度出发，剖析移动端性能监控的技术原理</a> 我现在所在的公司目前还没有自己的APM，这块的工作对项目还是很有用的。今年App已经在大力推广了，18年可以抽些时间搞点事情。</li>
</ol>
<p>除了技术的还订阅了《得到App》中的 “吴军-硅谷来信”和“何帆的北大读书俱乐部”，在思想上还是得到了一些启迪，给罗胖点赞。</p>
<hr>
<h2 id="投资"><a href="#投资" class="headerlink" title="投资"></a>投资</h2><p>因为公司在做港美股，今年也小试牛刀参与了一下港股，目前总体战绩还是亏损的，哈哈，今年是港股的大牛市，腾讯从年初的198左右飞身翻倍到400+，这样我都能亏损，也是自己佩服自己。之前也看到过唐巧写的<a href="http://blog.devtang.com/2017/05/24/talk-about-buying-stock/" title="每个人都应该买美股" target="_blank" rel="external">每个人都应该买美股</a>，确实我也是秉持一样的观点，每个人最好都能在空闲之余关注一下股票，尤其是港美股，很多我们耳熟能详的公司基本都选择在香港和纽交所上市，包括不限于阿里巴巴，腾讯，百度，新浪，微博等等。买股票能让你潜移默化的了解一些公司或者行业，但同时也你要学会规避风险。股票中还是有很多道理的，包括一些人性中的缺陷，贪婪和恐惧的博弈。</p>
<p>我很认同那句话：炒股就是对你所掌握的知识的一种变现方式。股票中赚钱的基本只有两种人，一种是价值投资的：他知识丰富，精通他投资的行业，通过自己掌握的知识很难赚不到钱。另外一种是投机主义者：多以证券交易员为主，他们精通各种金融知识，懂得严格止损止盈，他们每天都在等待机会找寻机会，长久来看不盈利还是很难的。说到这里我想到了“量化投资”，大家感兴趣的可以自己去了解一下。</p>
<p>18年我还会继续在业余时间学习一些金融知识，创建自己的策略，尽量规避风险，感觉这时Python就要大显身手了，还要多学习一下Python啊，并且做到不患得患失，不影响自己的工作🤓</p>
<hr>
<h2 id="健身"><a href="#健身" class="headerlink" title="健身"></a>健身</h2><p>称了一下，今年一年足足胖了10斤+，和工作加班变多，夜宵变多，饮食不规律，咖啡饮用量变多，运动变少有很大原因。以前还会经常参加公司的每周羽毛球活动的，偶尔早上还会去宝体跑上几公里，现在全没啦，值得吐槽的是办了一个半年健身卡，只去了4次😤，18年要运动多一些了！也是为了自己的健康，避免职业病！为自己和家人负责。</p>
<hr>
<h2 id="奔三"><a href="#奔三" class="headerlink" title="奔三"></a>奔三</h2><p>奔三途中的很大一部分压力都是来自结婚吧，啥时候结婚呢，是一个沉重的话题，虽然我和我女朋友私下已经将它提上日程了，但感觉还是有点遥远，主要是完全都要靠自己，最主要还是一个字，穷😑。女朋友还想在深圳买房，其实我也想，我俩都不太想回长沙。还是要借王健林的那句话，先定一个小目标，然后实现它，逐一攻克吧。希望18年进展顺利。</p>
<hr>
<h2 id="厨艺"><a href="#厨艺" class="headerlink" title="厨艺"></a>厨艺</h2><p>说到结婚，不只是物质上的欠缺，还有一些生活上的技能需要掌握，一些习惯需要改变。比较重要的一点就是下厨。17年在这方面做的很差，我基本没做过几道菜，17年办了一个自动续费的饿了么超级会员。可能是平时我有接触到饿了么的移动开发者，看过他们的分享，比较仰慕他们的技术，所以这一年成了他们App的重度用户🤓 （开个玩笑，肯定是自己懒啊👨‍🍳）</p>
<hr>
<h2 id="2018展望"><a href="#2018展望" class="headerlink" title="2018展望"></a>2018展望</h2><p><strong>技术上：</strong></p>
<ul>
<li>Swift 必须上车了，再不上车已经跟不上时代了。</li>
<li>Python用多深入以及应用下，使用场景还是比较广的，平时项目中的一些自动化全靠他了。</li>
<li>多产出：18年技术上还是要多向大佬们靠齐，多多产出，多多参与开源。说到这里，要说一下，今年不知道怎么骗到了霜神大佬的关注，哈哈<img src="http://upload-images.jianshu.io/upload_images/1457495-c8ab67114a70f2bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>(霜神看到了可别取消啊，给大佬递茶)18年要争取多“骗”几个大佬。</li>
</ul>
<p><strong>生活上：</strong></p>
<ul>
<li>健身要增多，主要是要把肚子减下去，预防职业病。</li>
<li>厨艺要开始磨炼了，少点外卖，提升生活质量。</li>
<li>18年要计划和女朋友出去旅行一次，开拓开拓视野。</li>
<li>争取早点结婚！</li>
</ul>
<hr>
<p>好啦，以上就是我的17年的总结了，基本就是一个大老粗的碎碎念，还有几个小时就到18年啦，感谢你看到最后，感谢你的时间，祝福你，也祝福自己，加油~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转眼2017年走到了尾声，之前很少有写&lt;code&gt;年终总结&lt;/code&gt;，如今已到了奔三的年纪，肩上的责任也越来越‘丰富’，每年做个总结，尽量避免每年‘瞎忙’吧。
    
    </summary>
    
    
      <category term="其他" scheme="http://superma.me/all-tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>iOS设计模式四部曲三:行为型模式内附Demo</title>
    <link href="http://superma.me/2017/10/18/iOS%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%9B%9B%E9%83%A8%E6%9B%B2%E4%B8%89-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%E5%86%85%E9%99%84Demo/"/>
    <id>http://superma.me/2017/10/18/iOS设计模式四部曲三-行为型模式内附Demo/</id>
    <published>2017-10-17T16:51:05.000Z</published>
    <updated>2017-10-17T16:58:36.000Z</updated>
    
    <content type="html"><![CDATA[<p> 本篇是四部曲的第三篇，第一篇请点这里<a href="http://www.jianshu.com/p/55f0e3b30e9c" target="_blank" rel="external">iOS设计模式四部曲(一):创建型模式</a>,第二篇请点击这里<a href="http://www.jianshu.com/p/8ae41a48021b" target="_blank" rel="external">iOS设计模式四部曲(二):结构型模式</a>。<a id="more"></a>由于个人能力有限，文中难免有一些遗漏或者错误，请各位看官不吝赐教！谢谢！本文所有Demo可以在我的Git上获取，<a href="https://github.com/maligh/DesignPatterns" target="_blank" rel="external">请点击这里</a></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1457495-2239f396849b8fc9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="第三篇行为型模式"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1457495-b27a7821529beb5d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="设计模式.png"></p>
<p>上图是整个设计模式的目录，这篇文章是其中的第三部分：行为型模式。行为型模式包括：<code>责任链模式（Chain of Responsibility）</code>，<code>命令模式（Command）</code>，<code>中介者模式（Mediator）</code>，<code>观察者模式（Observer）</code>，<code>备忘录模式（Memento）</code>，<code>策略模式（Strategy）</code>，<code>访问者模式（Visitor）</code>，<code>模板方法模式（TemplateMethod）</code>，<code>状态模式（State）</code>，<code>迭代器模式（Iterator）</code>，<code>解释器模式（Interpreter）</code>。下面我们就开始吧~</p>
<h2 id="责任链模式（Chain-of-Responsibility）："><a href="#责任链模式（Chain-of-Responsibility）：" class="headerlink" title="责任链模式（Chain of Responsibility）："></a>责任链模式（Chain of Responsibility）：</h2><p><strong>1.定义:</strong> 责任链模式（Chain of Responsibility Pattern）为请求创建了一个接收者对象的链。使多个对象都有机会处理请求，从而避免了请求的发送者和接受者之前的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，知道有对象处理它为止。<br><strong>2. 使用场景：</strong> 有多个对象可以处理同一个请求，具体哪个对象处理该请求由运行时确定。<br><strong>3. 具体实现：</strong> 这里举了一个实际中公司请假批假的例子，<a href="https://github.com/maligh/DesignPatterns/tree/master/MLDesignPatterns-OC/MLDesignPatterns-OC/ChainOfResponsibility" target="_blank" rel="external">具体请点击这里查看</a><br><strong>4.优点：</strong> 1.低耦合：将请求和处理分开，请求者可以不用知道是谁处理的。2.新增和修改新的处理类比较容易<br><strong>5.缺点：</strong> 每个请求都是从链头遍历到链尾，如果链比较长会产生一定的性能问题，调试起来也比较麻烦。<br><strong>6.注意事项:</strong> 避免超长链的情况出现</p>
<hr>
<h2 id="命令模式（Command）："><a href="#命令模式（Command）：" class="headerlink" title="命令模式（Command）："></a>命令模式（Command）：</h2><p><strong>1.定义:</strong> 命令模式将请求封装成对象，从而可用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销和恢复的操作。<br><strong>2. 使用场景：</strong> 在某些场合，比如要对行为进行”记录、撤销/重做、事务”等处理的时候。<br><strong>3. 具体实现：</strong> <a href="https://github.com/yuantiku/YTKNetwork" target="_blank" rel="external">YTKNetwork</a>就是用的命令模式，推荐大家学习。这里我举了一个吃饭点菜的例子，<a href="https://github.com/maligh/DesignPatterns/tree/master/MLDesignPatterns-OC/MLDesignPatterns-OC/Command" target="_blank" rel="external">具体请点击这里查看</a><br><strong>4.优点：</strong> 1.类间解耦：调用者与接收者之间没有任何依赖关系。2.扩展性良好：新的命令可以很容易添加到系统中去。<br><strong>5.缺点：</strong> 使用命令模式可能会导致系统有过多的具体命令类。</p>
<hr>
<h2 id="中介者模式（Mediator）："><a href="#中介者模式（Mediator）：" class="headerlink" title="中介者模式（Mediator）："></a>中介者模式（Mediator）：</h2><p><strong>1.定义:</strong> 中介者模式就是用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。<br><strong>2. 使用场景：</strong> 多个类相互依赖，形成了网状结构的时候可以考虑使用中介者模式。<br><strong>3. 具体实现：</strong> 这里举了一个聊天室的例子，<a href="https://github.com/maligh/DesignPatterns/tree/master/MLDesignPatterns-OC/MLDesignPatterns-OC/Mediator" target="_blank" rel="external">具体请点击这里查看</a><br><strong>4.优点：</strong> 1.解耦：通过中介者模式，我们可以将复杂关系的网状结构变成结构简单的以中介者为核心的星形结构，每个对象不再和它与之关联的对象直接发生相互作用，而是通过中介者对象来另一个对象发生相互作用。2.降低了类的复杂度，将一对多转化成了一对一。<br><strong>5.缺点：</strong>中介者模式在某些情况会膨胀得很大，而且逻辑复杂，中介类越多越复杂，越难以维护。<br><strong>6.注意事项:</strong> 类之间的依赖关系是必然存在的，所以不一定有多个依赖关系的时候就考虑使用中介者模式。中介者模式适用于多个对象之间的紧密耦合的情况，紧密耦合的定义标准是：在类图中出现了蜘蛛网状结构，这种情况就要考虑使用中介者模式，中介者模式可以把蜘蛛网梳理成星型结构，使原本复杂混乱的关系变得清晰简单。</p>
<hr>
<h2 id="观察者模式（Observer）："><a href="#观察者模式（Observer）：" class="headerlink" title="观察者模式（Observer）："></a>观察者模式（Observer）：</h2><p><strong>1.定义:</strong> 定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。<br><strong>2. 使用场景：</strong> 一个对象的状态发生改变，所有的依赖对象都将得到通知的时候。<br><strong>3. 具体实现：</strong> Objective-C中的通知以及KVO都是观察者模式的具体实现。这里举了一个找工作订阅的例子，<a href="https://github.com/maligh/DesignPatterns/tree/master/MLDesignPatterns-OC/MLDesignPatterns-OC/Observer" target="_blank" rel="external">具体请点击这里查看</a><br><strong>4.优点：</strong> 1.观察者和被观察者是抽象耦合的，扩展比较方便。2.建立一套触发机制。<br><strong>5.缺点：</strong> 1.如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。 2.如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。 3.观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。</p>
<hr>
<h2 id="备忘录模式（Memento）："><a href="#备忘录模式（Memento）：" class="headerlink" title="备忘录模式（Memento）："></a>备忘录模式（Memento）：</h2><p><strong>1.定义:</strong> 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就开奖对象恢复到原先保存的状态了。<br><strong>2. 使用场景：</strong> 需要存档的时候，比如说游戏中的存档。<br><strong>3. 具体实现：</strong> 打游戏时的存档，数据库的事务管理，SVN以及Git代码的版本控制系统等等都可以说成是备忘录模式的实例。这里我简单的举了一下例子，<a href="https://github.com/maligh/DesignPatterns/tree/master/MLDesignPatterns-OC/MLDesignPatterns-OC/Memento" target="_blank" rel="external">具体请点击这里查看</a><br><strong>4.优点：</strong> 1.给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史的状态。 2.实现了信息的封装，使得用户不需要关心状态的保存细节。<br><strong>5.缺点：</strong> 在一些场景下比较消耗资源。<br><strong>6.注意事项:</strong> 不要在频繁建立备份的场景中使用备忘录模式，比如说在for循环中。</p>
<hr>
<h2 id="策略模式（Strategy）："><a href="#策略模式（Strategy）：" class="headerlink" title="策略模式（Strategy）："></a>策略模式（Strategy）：</h2><p><strong>1.定义:</strong> 定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。<br><strong>2. 使用场景：</strong> 1.多个类只有在算法或行为上稍有不同的场景。2.算法需要自由切换的场景。3.需要屏蔽算法规则的场景。<br><strong>3. 具体实现：</strong> <a href="https://github.com/maligh/DesignPatterns/tree/master/MLDesignPatterns-OC/MLDesignPatterns-OC/Strategy" target="_blank" rel="external">具体请点击这里查看</a><br><strong>4.优点：</strong> 1.算法可以自由切换。 2.避免使用多重条件判断。 3.扩展性良好。<br><strong>5.缺点：</strong>1.策略类会增多。 2.所有策略类都需要对外暴露。<br><strong>6.注意事项:</strong> 如果一个系统的策略多于四个，就需要考虑使用混合模式，解决策略类膨胀的问题。</p>
<hr>
<h2 id="访问者模式（Visitor）："><a href="#访问者模式（Visitor）：" class="headerlink" title="访问者模式（Visitor）："></a>访问者模式（Visitor）：</h2><p><strong>1.定义:</strong> 访问者模式封装了一些作用于某种数据结构中的各元素操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作。<br><strong>2. 使用场景：</strong> 需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作”污染”这些对象的类，使用访问者模式将这些封装到类中。<br><strong>3. 具体实现：</strong> 这里举了一个悲观的人和乐观的人对待不同事物的反应的实例，<a href="https://github.com/maligh/DesignPatterns/tree/master/MLDesignPatterns-OC/MLDesignPatterns-OC/Visitor" target="_blank" rel="external">具体请点击这里查看</a>，如果想增加Action就比较方便，但是如果想增加一个既悲观又乐观的人就有一点麻烦了。<br><strong>4.优点：</strong> 1.符合单一职责原则。 2.优秀的扩展性。 3.灵活性高<br><strong>5.缺点：</strong>1.具体元素对访问者公布细节，违反了迪米特原则。 2.具体元素变更比较困难。 3.违反了依赖倒置原则，依赖了具体类，没有依赖抽象。</p>
<hr>
<h2 id="模板方法模式（TemplateMethod）："><a href="#模板方法模式（TemplateMethod）：" class="headerlink" title="模板方法模式（TemplateMethod）："></a>模板方法模式（TemplateMethod）：</h2><p><strong>1.定义:</strong> 定义一个操作中的算法的框架，而降一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。<br><strong>2. 使用场景：</strong> 1.多个子类有公有的方法，并且逻辑基本相同时。2.有重要、复杂的算法的时候，可以把核心算法设计为模板方法，周边的相关细节功能则由各个子类实现。<br><strong>3. 具体实现：</strong> 这里简单举了一个Android 和iOS项目的从code到发布的简易过程Demo，<a href="https://github.com/maligh/DesignPatterns/tree/master/MLDesignPatterns-OC/MLDesignPatterns-OC/TemplateMethod" target="_blank" rel="external">具体请点击这里查看</a><br><strong>4.优点：</strong> 1.封装不变部分，扩展可变部分。 2.提取公共代码，便于维护。 3.行为由父类控制，子类实现。<br><strong>5.缺点：</strong> 每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。</p>
<hr>
<h2 id="状态模式（State）："><a href="#状态模式（State）：" class="headerlink" title="状态模式（State）："></a>状态模式（State）：</h2><p><strong>1.定义:</strong> 当一个对象内在状态改变时允许其改变行为，这个对象看起来像改变了其类。<br><strong>2. 使用场景：</strong> 1.行为随状态改变而改变的场景。2.条件、分支判断语句的替代者。<br><strong>3. 具体实现：</strong> 这里举了一个不太恰当的例子，假如一支笔有3种状态可以切换，可以写钢笔字，圆珠笔字，毛笔字，<a href="https://github.com/maligh/DesignPatterns/tree/master/MLDesignPatterns-OC/MLDesignPatterns-OC/State" target="_blank" rel="external">具体请点击这里查看</a>。再举一个实际中典型的例子就是酒店管理房间的时候，房间应该会有三种状态：空闲，已预订，已入住，同理。<br><strong>4.优点：</strong> 1.结构清晰，避免了过多的选择判断语句。2.封装性比较好。<br><strong>5.缺点：</strong> 子类会比较多，增加了复杂度。</p>
<hr>
<h2 id="迭代器模式（Iterator）："><a href="#迭代器模式（Iterator）：" class="headerlink" title="迭代器模式（Iterator）："></a>迭代器模式（Iterator）：</h2><p><strong>1.定义:</strong> 迭代器模式提供一种方法访问一个容器对象中各个元素，而又不需暴露该对象的内部细节。<br><strong>2. 使用场景：</strong> 一个聚合对象有遍历的需求<br><strong>3. 具体实现：</strong> 在 Cocoa Touch 中的 <code>NSEnumerator类</code> 就实现了迭代器模式。还有<code>基于块的枚举</code>也是迭代器模式的实现等等<br><strong>4.优点：</strong> 1.它支持以不同的方式遍历一个聚合对象。2.增加新的collection类和迭代器类都很方便。<br><strong>5.缺点：</strong> 迭代器和collection类是对应的，增加新的collection类就会增加新的迭代器，类的个数成对增加，可能会增加系统复杂度。</p>
<hr>
<h2 id="解释器模式（Interpreter）："><a href="#解释器模式（Interpreter）：" class="headerlink" title="解释器模式（Interpreter）："></a>解释器模式（Interpreter）：</h2><p><strong>1.定义:</strong> 给定一门语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。<br><strong>2. 使用场景：</strong> 解释器模式在实际项目中用到的比较少，正则表达式就是用的解释器模式。<br><strong>3. 具体实现：</strong> 正则表达式。<br><strong>4.优点：</strong> 容易改变和扩展问法。<br><strong>5.缺点：</strong> 效率是严重的问题。</p>
<hr>
<p><strong>扩展阅读：</strong><br> <a href="http://www.jianshu.com/p/6b302c7fe987" target="_blank" rel="external">iOS 中的 21 种设计模式</a><br><a href="https://github.com/kamranahmedse/design-patterns-for-humans" target="_blank" rel="external">https://github.com/kamranahmedse/design-patterns-for-humans</a></p>
<hr>
<p><strong>EOF:</strong>这篇文章通过<a href="https://github.com/maligh/DesignPatterns/tree/master/MLDesignPatterns-OC/MLDesignPatterns-OC/" target="_blank" rel="external">Demo</a>梳理了设计模式中的行为型模式，由于个人能力有限，难免有一些遗漏或者错误，<strong>还请各位看官不吝赐教！</strong> 本文已同步到<a href="http://www.superma.me/2017/10/18/iOS%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%9B%9B%E9%83%A8%E6%9B%B2%E4%B8%89-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%E5%86%85%E9%99%84Demo/" target="_blank" rel="external">个人博客</a>，<strong>欢迎关注，欢迎点赞，欢迎star，欢迎一起交流，一起进步！</strong>🤓</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 本篇是四部曲的第三篇，第一篇请点这里&lt;a href=&quot;http://www.jianshu.com/p/55f0e3b30e9c&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;iOS设计模式四部曲(一):创建型模式&lt;/a&gt;,第二篇请点击这里&lt;a href=&quot;http://www.jianshu.com/p/8ae41a48021b&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;iOS设计模式四部曲(二):结构型模式&lt;/a&gt;。
    
    </summary>
    
      <category term="设计模式" scheme="http://superma.me/all-categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://superma.me/all-tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Objective-C" scheme="http://superma.me/all-tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>iOS设计模式四部曲二:结构型模式内附Demo</title>
    <link href="http://superma.me/2017/09/05/iOS%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%9B%9B%E9%83%A8%E6%9B%B2%E4%BA%8C-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F%E5%86%85%E9%99%84Demo/"/>
    <id>http://superma.me/2017/09/05/iOS设计模式四部曲二-结构型模式内附Demo/</id>
    <published>2017-09-04T17:03:39.000Z</published>
    <updated>2017-09-04T17:12:41.000Z</updated>
    
    <content type="html"><![CDATA[<p> 本篇是四部曲的第二篇，第一篇请点这里<a href="http://www.jianshu.com/p/55f0e3b30e9c" target="_blank" rel="external">iOS设计模式四部曲(一):创建型模式 内附Demo</a>，关于设计模式强烈推荐图书《Head First设计模式》以及《研磨设计模式》<a id="more"></a>由于个人能力有限，文中难免有一些遗漏或者错误，请各位看官不吝赐教！谢谢！本文所有Demo可以在我的Git上获取，<a href="https://github.com/maligh/DesignPatterns" target="_blank" rel="external">请点击这里</a></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1457495-9bef37686fbfa917.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="第二篇来了"><br><img src="http://upload-images.jianshu.io/upload_images/1457495-b27a7821529beb5d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="设计模式.png"></p>
<p>废话不多说，上图是整个设计模式的目录，这篇文章是其中的第二部分：结构型模式。结构型模式包括：<code>适配器模式（Adapter）</code>，<code>桥接模式（Bridge）</code>，<code>装饰器模式（Decorator）</code>，<code>组合模式（Composite）</code>，<code>外观模式（Facade）</code>，<code>享元模式（Flyweight）</code>，<code>代理模式（Proxy）</code>。下面我们就开始吧~</p>
<hr>
<h2 id="适配器模式（Adapter）："><a href="#适配器模式（Adapter）：" class="headerlink" title="适配器模式（Adapter）："></a>适配器模式（Adapter）：</h2><p><strong>1.定义:</strong> 适配器模式将一个类的接口变成调用者所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。(举一个现实中的实例：比如转接头)。<br><strong>2. 使用场景：</strong> 扩展应用或者组件时，而被集成进来的又不符合现在的接口，这个时候可以考虑使用适配器模式。<br><strong>3. 具体实现：</strong> 这里用举一个实际的例子，同声传译。举了一个虚拟的国际大会场景，主持人只会说英语，然后马云先生又听不懂英语（当然只是假设，事实是说的比中文都6），在乔布斯演讲之后，就到马云演讲，这个时候就需要一个翻译，去告诉马云可以开始你的表演啦😄，具体<a href="https://github.com/maligh/DesignPatterns/tree/master/MLDesignPatterns-OC/MLDesignPatterns-OC/Adapter" target="_blank" rel="external">Demo点击这里查看</a><br><strong>4.优点：</strong> 通过使用适配器让不兼容的接口变成了兼容，让调用者从实现类的接口解耦。在不修改原有代码的基础上增加新的适配器类，所以灵活性和扩展性比较好，哪天不想用了，就一起卸载掉。<br><strong>5.缺点：</strong> 只有集成具有类似功能的组件时，适配器模式才具有使用价值。具有相似功能具体指：API不一样，但是功能是相似的。<br><strong>6.注意事项:</strong> 适配器模式一般不是为了解决还处在于开发阶段的问题，一般都是解决正在服役项目的扩展问题。</p>
<hr>
<h2 id="桥接模式（Bridge）："><a href="#桥接模式（Bridge）：" class="headerlink" title="桥接模式（Bridge）："></a>桥接模式（Bridge）：</h2><p><strong>1.定义:</strong> 桥接模式就是将抽象部分和实现部分解耦，从而使得两者可以独立的变化。<br><strong>2. 使用场景：</strong> 重用性要求较高的不希望或不适用使用继承的场景。也就是说当继承N层，达到层级有点爆炸的时候可以考虑使用此模式。<br><strong>3. 具体实现：</strong> 这里举了一个App不同模块可以切换不同主题的例子，桥接模式主打的是组合优于继承，<a href="https://github.com/maligh/DesignPatterns/tree/master/MLDesignPatterns-OC/MLDesignPatterns-OC/Bridge" target="_blank" rel="external">具体Demo点击查看</a>，如果没有用桥接模式的话，可能就会出现<code>MyRedModule</code>，<code>MyBlueModule</code>这样的类<br><strong>4.优点：</strong> 此模式分离了应用的抽象部分与实现部分，有利于扩充。<br><strong>5.缺点：</strong> 桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围具有一定的局限性。<br><strong>6.注意事项:</strong> 并不是一涉及继承就要考虑使用桥接模式，不然还要继承做什么？桥接模式的目的就是要对变化进行封装，尽可能的把变化的因素封装到最细最小的单元中，避免风险扩散。所以当发现类的继承有N层的时候，才需要去考虑使用该模式。</p>
<hr>
<h2 id="装饰器模式（Decorator）："><a href="#装饰器模式（Decorator）：" class="headerlink" title="装饰器模式（Decorator）："></a>装饰器模式（Decorator）：</h2><p><strong>1.定义:</strong> 装饰模式能动态的给一个对象添加一些额外的职责。就增加功能来说，装饰模式会比通过继承生成子类更为灵活。<br><strong>2. 使用场景：</strong> 需要动态地给一个对象增加功能，这些功能也可以动态地被撤销。<br><strong>3. 具体实现：</strong> Objective-C中的Category 就是装饰器模式的一种应用。这里举了一个鸡肉堡的例子，<a href="https://github.com/maligh/DesignPatterns/tree/master/MLDesignPatterns-OC/MLDesignPatterns-OC/Decorator" target="_blank" rel="external">具体Demo点击查看</a><br><strong>4.优点：</strong> 装饰器模式中定义的行为，能够在不创建大量子类的情况下，组合起来实现复杂的效果，比继承更加灵活。<br><strong>5.缺点：</strong> 装饰器模式会导致设计中出现许多的小对象，会让系统变得更加复杂，比如说出错调试时寻找错误可能需要逐级排查。</p>
<hr>
<h2 id="组合模式（Composite）："><a href="#组合模式（Composite）：" class="headerlink" title="组合模式（Composite）："></a>组合模式（Composite）：</h2><p><strong>1.定义:</strong> 组合模式将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。<br><strong>2. 使用场景：</strong> 维护和展示部分-整体关系的场景，在具有整体和部分的层次结构中，希望通过一种方式忽略整体与部分的差异，可以一致地对待它们的时候。<br><strong>3. 具体实现：</strong> 这里举一个文件系统的例子<br><img src="http://upload-images.jianshu.io/upload_images/1457495-8a193f7beaa6017c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>这里有这个目录下有<code>文件夹Composite</code>和<code>main实现文件</code>，<code>文件夹Composite</code>下有<code>实现文件</code>和<code>头文件</code>。<a href="https://github.com/maligh/DesignPatterns/tree/master/MLDesignPatterns-OC/MLDesignPatterns-OC/Composite" target="_blank" rel="external">Demo点击这里查看</a></p>
<p><strong>4.优点：</strong> 1.高层模块调用简单。2.节点自由增加，而不必更改原来代码。3.叶子对象可以被组合成更复杂的容器对象，而这个容器对象又可以被组合，这样不断递归下去，可以形成复杂的树形结构。<br><strong>5.缺点：</strong> 使设计变得更加抽象，对象的业务规则如果很复杂，则实现组合模式具有很大挑战性，而且不是所有的方法都与叶子对象子类都有关联。<br><strong>6.注意事项:</strong> 当使用这个属性结构的调用组件能够通过同一个类或者协议来使用书中包含的所有的对象时，才能证明正确的实现了此模式。</p>
<hr>
<h2 id="外观模式（Facade）："><a href="#外观模式（Facade）：" class="headerlink" title="外观模式（Facade）："></a>外观模式（Facade）：</h2><p><strong>1.定义:</strong> 外观模式要求一个子系统的外部与内部的通信必须通过一个统一的对象进行。外观模式提供一个高层次的接口，用来访问子系统中的一群接口。<br><strong>2. 使用场景：</strong> 当一个复杂子系统需要提供一个简单的调用接口时可以使用外观模式。<br><strong>3. 具体实现：</strong> 外观模式比较容易理解，这里举一个家电管家的例子，命令起床，命令睡觉。家电管家帮你做关灯，拉窗帘等等一系列操作。<a href="https://github.com/maligh/DesignPatterns/tree/master/MLDesignPatterns-OC/MLDesignPatterns-OC/Facade" target="_blank" rel="external">具体Demo请点击这里查看</a><br><strong>4.优点：</strong> 使用此模式可以将复杂的API代码隐藏到一个简单的接口中，减少调用者直接对复杂API的依赖和耦合。修改时也只需要修改简单的接口即可。<br><strong>5.缺点：</strong> 不太遵守开闭原则，一旦发现有一些操作的时候，或者在增加新的子系统的时候，可能需要修改外观类代码，可能会造成一些风险。</p>
<hr>
<h2 id="享元模式（Flyweight）："><a href="#享元模式（Flyweight）：" class="headerlink" title="享元模式（Flyweight）："></a>享元模式（Flyweight）：</h2><p><strong>1.定义:</strong> 享元模式就是运行共享技术有效地支持大量细粒度对象的复用<br><strong>2. 使用场景：</strong> 系统中存在大量的相似对象，由于这类对象的大量使用可能会造成系统内存资源浪费，而且这些对象的状态大部分可以外部化，这个时候可以考虑享元模式。在iOS中，我们用到的UITableView 重用机制就是享元模式的典型应用。<br><strong>3. 具体实现：</strong> 这里通过了一个画圆的Demo来演示一下享元模式，<a href="https://github.com/maligh/DesignPatterns/tree/master/MLDesignPatterns-OC/MLDesignPatterns-OC/Flyweight" target="_blank" rel="external">具体Demo请点击这里查看</a><br><strong>4.优点：</strong> 通过共享极大的减少了对象实例的个数，节省了内存开销。<br><strong>5.缺点：</strong> 1.提高了系统的复杂度，需要分离出外部状态和内部状态。 2.这些类必须有一个工厂对象加以控制。</p>
<hr>
<h2 id="代理模式（Proxy）："><a href="#代理模式（Proxy）：" class="headerlink" title="代理模式（Proxy）："></a>代理模式（Proxy）：</h2><p><strong>1.定义:</strong> 代理模式为其他对象提供一种代理以控制对这个对象的访问。<br><strong>2. 使用场景：</strong> 想在访问一个类时做一些控制。<br><strong>3. 具体实现：</strong> 这里举一个实际的例子，就是火车票代售点，<a href="https://github.com/maligh/DesignPatterns/tree/master/MLDesignPatterns-OC/MLDesignPatterns-OC/Proxy" target="_blank" rel="external">具体实现Demo请点击这里查看</a><br><strong>4.优点：</strong> 1、职责清晰。 2、高扩展性。<br><strong>5.缺点：</strong> 增加了系统的复杂度<br><strong>6.注意事项:</strong> 1、和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。 2、和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。</p>
<hr>
<p><strong>EOF:</strong>这篇文章通过<a href="https://github.com/maligh/DesignPatterns/tree/master/MLDesignPatterns-OC/MLDesignPatterns-OC/" target="_blank" rel="external">Demo</a>梳理了设计模式中的结构型模式，由于个人能力有限，难免有一些遗漏或者错误，<strong>还请各位看官不吝赐教！</strong> 最近工作有点忙，剩下的部分会尽量抽时间早点完成。本文已同步到<a href="http://www.superma.me/2017/09/05/iOS%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%9B%9B%E9%83%A8%E6%9B%B2%E4%BA%8C-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F%E5%86%85%E9%99%84Demo/" target="_blank" rel="external">个人博客</a>，<strong>欢迎关注，欢迎点赞，欢迎star，欢迎一起交流，一起进步！</strong>🤓</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 本篇是四部曲的第二篇，第一篇请点这里&lt;a href=&quot;http://www.jianshu.com/p/55f0e3b30e9c&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;iOS设计模式四部曲(一):创建型模式 内附Demo&lt;/a&gt;，关于设计模式强烈推荐图书《Head First设计模式》以及《研磨设计模式》
    
    </summary>
    
      <category term="设计模式" scheme="http://superma.me/all-categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://superma.me/all-tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Objective-C" scheme="http://superma.me/all-tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>iOS设计模式四部曲一创建型模式内附Demo</title>
    <link href="http://superma.me/2017/08/22/iOS%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%9B%9B%E9%83%A8%E6%9B%B2%E4%B8%80%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%E5%86%85%E9%99%84Demo/"/>
    <id>http://superma.me/2017/08/22/iOS设计模式四部曲一创建型模式内附Demo/</id>
    <published>2017-08-21T17:18:45.000Z</published>
    <updated>2017-08-21T17:25:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>  最近刚重温完经典书籍<a href="http://www.jianshu.com/p/862b064e82e0" target="_blank" rel="external">《EffectiveObjective-C2.0编写高质量iOS与OSX代码的52个有效方法》</a>，接下来准备把设计模式扫扫盲<a id="more"></a>，强烈推荐图书《Head First设计模式》，如果看完了有空可以翻翻《大话设计模式》或者《设计模式之禅》，这几篇就是阅读学习设计模式的产物吧。因设计模式大致可分三种类型以及MVX架构系列，所以总共分了4篇来讲解：<code>创建型模式篇</code>，<code>结构性模式篇</code>，<code>行为型模式篇</code>，<code>架构型模式篇</code>，这是第一篇，由于个人能力有限，难免有一些遗漏或者错误，请各位看官不吝赐教！谢谢！本文所有Demo可以在我的Git上获取，<a href="https://github.com/maligh/DesignPatterns" target="_blank" rel="external">请点击这里</a></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1457495-b27a7821529beb5d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="设计模式.png"></p>
<p>闲言碎语不多讲，上图是本系列的一个总体大纲。这篇文章是第一部：创建型模式。不过在开讲之前首先说一下设计模式的六大原则：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1457495-4cac842b1e171838.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>关于这六大原则的解释，具体可以看我之前整理的一篇文章，<a href="http://www.jianshu.com/p/807bc228dbc2" target="_blank" rel="external">请点击这里前往</a><br>创建型模式包括：<code>原型模式</code>，<code>单例模式</code>，<code>工厂方法模式</code>，<code>抽象工厂模式</code>，<code>建造者模式</code>，下面我们就通过<a href="https://github.com/maligh/DesignPatterns" target="_blank" rel="external">Demo</a>来一个一个讲解。</p>
<hr>
<h2 id="原型模式（Prototype）："><a href="#原型模式（Prototype）：" class="headerlink" title="原型模式（Prototype）："></a>原型模式（Prototype）：</h2><p><strong>1. 定义：</strong>原型模式是通过克隆已有的对象来创建新的对象，已有的对象称为原型。通俗来讲，原型模式就是允许你创建现有对象的副本并根据需要进行修改，而不是从头开始创建对象并进行设置。<br><strong>2. 使用场景：</strong>通过初始化产生一个对象需要非常繁琐的准备步骤，也就是新生成一个对象的代价比较大，则可以考虑使用原型模式。<br><strong>3. 具体实现：</strong>原型模式实现起来比较简单，iOS实现这个模式用的就是<code>copy</code>方法，如果是类使用<code>copy</code>，那这个类就要实现。<code>NSCopying</code>协议中的<code>copyWithZone</code>方法，告诉程序如何复制该对象。（当然也可以自己定义协议和自定义copy方法来克隆，但是不建议这样做)。具体代码可以看<a href="https://github.com/maligh/DesignPatterns/tree/master/MLDesignPatterns-OC/MLDesignPatterns-OC/Prototype" target="_blank" rel="external">Demo</a>。另外在<code>Foudation</code>框架中你也会找到大量实现了<code>NSCopying</code>或者<code>NSMutableCopying</code>的类。<br><strong>4.优点：</strong> 在某些场景可以避免内存开销大的创建初始化动作。<br><strong>5.缺点：</strong> 基本没有缺点可言。<br><strong>6.注意事项:</strong> 涉及到<code>copy</code>，注意下深复制和浅复制就好。</p>
<hr>
<h2 id="单例模式（Singleton）："><a href="#单例模式（Singleton）：" class="headerlink" title="单例模式（Singleton）："></a>单例模式（Singleton）：</h2><p><strong>1.定义:</strong> 单例模式能够确保某个类在应用中只存在一个实例，创建之后会向整个系统共用这个实例。<br><strong>2. 使用场景：</strong> 需要用来保存全局的状态，并且不和任何作用域绑定的时候可以考虑单例。<br><strong>3. 具体实现：</strong><br>最简单最常见的一种实现方式:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">+ (instancetype)sharedInstance &#123;</div><div class="line">    static id shareInstance;</div><div class="line">    static dispatch_once_t onceToken;</div><div class="line">    dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">        shareInstance = [[self alloc] init];</div><div class="line">    &#125;);</div><div class="line">    return shareInstance;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>4.优点：</strong>在某些场景节省了一些内存开销，尤其是对一个需要频繁创建销毁的对象。<br><strong>5.缺点：</strong>单例对象一旦建立，对象指针是保存在静态区的，单例对象在堆中分配的内存空间，会在应用程序终止后才会被释放。虽然也可以做到提前释放，但一般很少这样去做。另外单例类无法继承，扩展很困难。<br><strong>6.注意事项:</strong> 单例模式比较常用，也可能是很多初级工程师唯一会使用的设计模式。这里还是要尽量避免滥用单例，大家可以查看<a href="https://www.objccn.io/issue-13-2/" target="_blank" rel="external">这篇文章</a> 另外还要防止一下对单例对象的<code>copy</code>操作。</p>
<hr>
<h2 id="工厂方法模式（FactoryMethod）："><a href="#工厂方法模式（FactoryMethod）：" class="headerlink" title="工厂方法模式（FactoryMethod）："></a>工厂方法模式（FactoryMethod）：</h2><p><strong>1.定义:</strong> 定义一个用于创建对象的接口，让子类决定实例化哪一个类。<br><strong>2. 使用场景：</strong> 当存在多个类共同实现一个协议或者共同继承一个基类的时候，需要创建不同的对象，这个时候就可以考虑是否有必要使用工厂类进行管理。<br><strong>3. 具体实现：</strong>  这里引用《设计模式之禅》一书中女娲造人的示例，<a href="https://github.com/maligh/DesignPatterns/tree/master/MLDesignPatterns-OC/MLDesignPatterns-OC/FactoryMethod" target="_blank" rel="external">具体实现请看demo</a>，另外还有工厂方法模式还可以缩小成简单工厂模式，形如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//CarFactory.m</div><div class="line">+ (Car *)createCarWithType:(NSIntger)passengersCount &#123;</div><div class="line">    if (passengersCount &lt; 2) &#123;</div><div class="line">        return [[SportCar alloc] init];</div><div class="line">    &#125; else if (passengersCount &lt; 4) &#123;</div><div class="line">        return [[NormalCar alloc] init];</div><div class="line">    &#125; else &#123;</div><div class="line">        return [[SUV alloc] init];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>但简单工厂模式的耦合和扩展方面存在一些问题，基本所有使用简单工厂模式的地方都可以用<code>依赖注入</code>来解决掉这个问题。<br><strong>4.优点：</strong> 1.在工厂方法中，用户只需要知道所要产品的具体工厂，不需要知道具体的创建过程，甚至不需要具体产品类。2.在系统增加新的产品时，我们只需要添加一个具体产品类和对应的实现工厂，无需对原工厂进行任何修改，很好地符合了“开闭原则”。<br><strong>5.缺点：</strong> 每次增加一个产品时，都需要增加一个具体类和对象实现工厂，代码量会增加，也增加了系统的复杂度。</p>
<hr>
<h2 id="抽象工厂模式（AbstractFactory）："><a href="#抽象工厂模式（AbstractFactory）：" class="headerlink" title="抽象工厂模式（AbstractFactory）："></a>抽象工厂模式（AbstractFactory）：</h2><p><strong>1.定义:</strong> 抽象工厂模式是工厂方式模式的升级版本，抽象工厂模式允许调用组件在不了解创建对象所需类的情况下，创建一组相关或者互相依赖的对象。<br><strong>2. 使用场景：</strong> 一个对象族有相同的约束时可以使用抽象工厂模式。<br><strong>3. 具体实现：</strong> 这里引用了一个生产门的工厂，木门需要搭配木门安装工，铁门需要搭配铁门安装工，<a href="https://github.com/maligh/DesignPatterns/tree/master/MLDesignPatterns-OC/MLDesignPatterns-OC/AbstractFactory" target="_blank" rel="external">具体实现请看demo</a><br><strong>4.优点：</strong> 良好的封装性：抽象工厂模式允许调用组件不必了解创建对象使用的类，也不必知道为什么选择这些类，因为我可以在不修改调用组件的情况下，对使用的类进行修改。<br><strong>5.缺点：</strong>  扩展产品族困难，需要更改接口及其下所有子类(什么是产品族：在抽象工厂模式中，产品族是指由同一个工厂生产的。例如苹果手机，苹果平板，苹果电脑)。</p>
<hr>
<h2 id="建造者模式（Builder）："><a href="#建造者模式（Builder）：" class="headerlink" title="建造者模式（Builder）："></a>建造者模式（Builder）：</h2><p><strong>1.定义:</strong> 将一个复杂的对象的构建与他的表示分离，使得同样的构建过程可以创建不同的表示。<br><strong>2. 使用场景：</strong> 当创建多种风格的对象时或者创建对象时涉及很多步骤，可以使用建造者模式。<br><strong>3. 具体实现：</strong> 这里举了一个手抓饼的例子，5元的不辣手抓饼需要添加（生菜 + 火腿肠 + 鸡蛋，味精 + 番茄酱），10元的变态辣手抓饼需要添加(生菜 + 热狗 + 肉松 + 里脊 + 芝士，辣椒 + 辣酱 + 麻酱 + 干辣椒 + 剁辣椒 + 老干妈 + 辣椒油)，<a href="https://github.com/maligh/DesignPatterns/tree/master/MLDesignPatterns-OC/MLDesignPatterns-OC/Builder" target="_blank" rel="external">具体实现请看demo</a><br><strong>4.优点：</strong> 1.将产品的创建过程与产品本身分离开来，可以使用相同的创建过程来得到不同的产品。2.每一个具体建造者都相对独立，因此可以很方便地替换具体建造者或增加新的具体建造者。<br><strong>5.缺点：</strong> 1.建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。2.如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。</p>
<hr>
<p><strong>EOF :</strong> 这篇文章通过<a href="https://github.com/maligh/DesignPatterns/tree/master/MLDesignPatterns-OC/MLDesignPatterns-OC/" target="_blank" rel="external">Demo</a>梳理了设计模式中的创建型模式，由于个人能力有限，难免有一些遗漏或者错误，还请各位看官不吝赐教！下周会给大家带来第二篇<code>结构性模式篇</code>，本文已同步到<a href="http://www.superma.me/2017/08/22/iOS%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%9B%9B%E9%83%A8%E6%9B%B2%E4%B8%80%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%E5%86%85%E9%99%84Demo/" target="_blank" rel="external">个人博客</a>，<strong>欢迎关注，欢迎点赞，欢迎star，欢迎一起交流，一起进步！</strong>🤓</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  最近刚重温完经典书籍&lt;a href=&quot;http://www.jianshu.com/p/862b064e82e0&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《EffectiveObjective-C2.0编写高质量iOS与OSX代码的52个有效方法》&lt;/a&gt;，接下来准备把设计模式扫扫盲
    
    </summary>
    
      <category term="设计模式" scheme="http://superma.me/all-categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://superma.me/all-tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Objective-C" scheme="http://superma.me/all-tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>重温《EffectiveObjective-C2.0编写高质量iOS与OSX代码的52个有效方法》</title>
    <link href="http://superma.me/2017/08/06/%E9%87%8D%E6%B8%A9%E3%80%8AEffectiveObjective-C2-0%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FiOS%E4%B8%8EOSX%E4%BB%A3%E7%A0%81%E7%9A%8452%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95%E3%80%8B/"/>
    <id>http://superma.me/2017/08/06/重温《EffectiveObjective-C2-0编写高质量iOS与OSX代码的52个有效方法》/</id>
    <published>2017-08-05T17:06:36.000Z</published>
    <updated>2017-08-09T15:50:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在重温这本OC经典之作《Effective Objective-C 2.0编写高质量iOS与OS X代码的52个有效方法》，这篇文章算是重温之后的产物吧<a id="more"></a>，读完这篇文章你将快速读完这本书，由于个人能力有限，难免有一些遗漏或者错误，请各位看官不吝赐教~谢谢~同时如果有任何问题也可以在下方留言，欢迎一起交流进步~另外由于篇幅原因，书中一些基础知识的介绍文中就省略掉了~</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1457495-debf9e0c37687e51.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="目录"><br>上面就是这本书的目录，可以<a href="https://pan.baidu.com/s/1bpCj0i7" target="_blank" rel="external">点击这里下载</a>PDF版，原版英文版PDF我也有存~</p>
<hr>
<h2 id="第一章：熟悉Objective-C"><a href="#第一章：熟悉Objective-C" class="headerlink" title="第一章：熟悉Objective-C"></a>第一章：熟悉Objective-C</h2><h3 id="第一条：了解Objective-C语言的起源"><a href="#第一条：了解Objective-C语言的起源" class="headerlink" title="第一条：了解Objective-C语言的起源"></a>第一条：了解Objective-C语言的起源</h3><ol>
<li><code>Objective-C</code>从Smalltalk语言是从<code>Smalltalk</code>语言演化而来，<br><code>Smalltalk</code>是消息语言的鼻祖。</li>
<li><code>Objective-C</code>是<code>C语言</code>的超集，在<code>C语言</code>基础上添加了面向对象等特性，可能一开始接触时你会觉得语法有点奇怪，那是因为<code>Objective-C</code>使用了动态绑定的<code>消息结构</code>，而<code>Java</code>，<code>C++</code>等等语言使用的是函数调用。</li>
<li><code>消息结构</code>与<code>函数调用</code>的关键区别在于：函数调用的语言，在编译阶段由<code>编译器</code>生成一些<code>虚方法表</code>，在运行时从这个表找到所要执行的方法去执行。而使用了动态绑定的<code>消息结构</code>在运行时接到一条消息，接下来要执行什么代码是运行期决定的，而不是编译器。</li>
</ol>
<h3 id="第二条：-在类的文件中尽量少引用其他头文件"><a href="#第二条：-在类的文件中尽量少引用其他头文件" class="headerlink" title="第二条： 在类的文件中尽量少引用其他头文件"></a>第二条： 在类的文件中尽量少引用其他头文件</h3><ol>
<li>如果需要引用一个类文件时，只是需要使用类名，不需要知道其中细节，可以用<code>@class xx.h</code>，这样做的好处会减少一定的编译时间。如果是用的<code>#import</code>全部导入的话，会出现<code>a.h</code> import了<code>b.h</code>,当<code>c.h</code> 又import <code>a.h</code>时，把<code>b.h</code>也都导入了，如果只是用到类名，真的比较浪费，也不够优雅</li>
<li>有时候无法使用<code>@class</code>向前声明，比如某个类要遵循一项协议，这个协议在另外一个类中声明的，可以将协议这部分单独放在一个头文件，或者放在分类当中，以降低引用成本。</li>
</ol>
<h3 id="第三条：多用字面量语法，少用与之等价的方法"><a href="#第三条：多用字面量语法，少用与之等价的方法" class="headerlink" title="第三条：多用字面量语法，少用与之等价的方法"></a>第三条：多用字面量语法，少用与之等价的方法</h3><p>1.多使用字面量语法来创建字符串，数组，字典等。<br><strong>传统创建数组方法:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">NSArray *languages = [NSArray arrayWithObjects:@&quot;PHP&quot;, @&quot;Objective-C&quot;, someObject, @&quot;Swift&quot;, @&quot;Python&quot;, nil];</div><div class="line">NSString *Swift = [languages objectAtIndex:2];</div><div class="line">NSDictionary *dict = [NSDictionary dictionaryWithObjectsAndKeys:@&quot;key&quot;, @&quot;value&quot;, nil];</div><div class="line">NSString *value = [languages objectForKey:@&quot;key&quot;];</div></pre></td></tr></table></figure></p>
<p><strong>字面量:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">NSArray *languages = @[@&quot;PHP&quot;, @&quot;Objective-C&quot;, someObject, @&quot;Swift&quot;, @&quot;Python&quot;];</div><div class="line">NSString *Swift = languages[2];</div><div class="line">NSDictionary *dict = @&#123;@&quot;key&quot; : @&quot;value&quot;&#125;;</div><div class="line">NSString *value = languages[@&quot;key&quot;];</div></pre></td></tr></table></figure></p>
<p>这样做的好处：使代码更简洁，易读，也会避免nil问题。比如languages数据中 someObject 如果为nil时，字面量语法就会抛出异常，而使用传统方法创建的languages数组值确是<code>@[@&quot;PHP&quot;, @&quot;Objective-C&quot;];</code>因为字面量语法其实是一种语法糖，效果是先创建了一个数组，然后再把括号中的对象都加到数组中来。<br>不过字面量语法有一个小缺点就是创建的数组，字符串等等对象都是不可变的，如果想要可变的对象需要自己多执行一步<code>mutableCopy</code>，例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSMutableArray *languages = [@[@&quot;PHP&quot;, @&quot;Objective-C&quot;, @&quot;Swift&quot;, @&quot;Python&quot;] mutableCopy];</div></pre></td></tr></table></figure></p>
<h3 id="第四条：多用类型常量，少用-define预处理指令"><a href="#第四条：多用类型常量，少用-define预处理指令" class="headerlink" title="第四条：多用类型常量，少用#define预处理指令"></a>第四条：多用类型常量，少用#define预处理指令</h3><p><a href="http://www.jianshu.com/p/064b5b82a3a2" target="_blank" rel="external">第4条第5条看这里</a></p>
<h3 id="第五条：多用枚举表示状态、选项、状态码"><a href="#第五条：多用枚举表示状态、选项、状态码" class="headerlink" title="第五条：多用枚举表示状态、选项、状态码"></a>第五条：多用枚举表示状态、选项、状态码</h3><p><a href="http://www.jianshu.com/p/064b5b82a3a2" target="_blank" rel="external">第4条第5条看这里</a></p>
<hr>
<h2 id="第二章：对象、消息、运行期"><a href="#第二章：对象、消息、运行期" class="headerlink" title="第二章：对象、消息、运行期"></a>第二章：对象、消息、运行期</h2><h3 id="第六条：理解“属性”这一概念"><a href="#第六条：理解“属性”这一概念" class="headerlink" title="第六条：理解“属性”这一概念"></a>第六条：理解“属性”这一概念</h3><p>这一条讲的是属性的基本概念，以及属性的各种修饰符，这些就不多啰嗦了，这里强调一下:</p>
<ol>
<li>定义对外开放的属性时候尽量做到暴露权限最小化，不希望被修改的属性要加上<code>readonly</code>。</li>
<li><code>atomic</code> 并不能保证多线程安全，例如一个线程连续多次读取某个属性的值，而同时还有别的线程在修改这个属性值得时候，也还是一样会读到不同的值。atomic 的原理只是在 setter and getter 方法中加了一个<code>@synchronized(self)</code>，所以iOS开发中属性都要声明为<code>nonatomic</code>,因为atomic严重影响了性能，但是在Mac OSX上开发却通常不存在这个性能问题</li>
<li>说一下下面的哪个属性声明有问题<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic, strong) NSArray *arrayOfStrong;</div><div class="line">@property (nonatomic, copy) NSArray *arrayOfCopy;</div><div class="line">@property (nonatomic, strong) NSMutableArray *mutableArrayOfStrong;</div><div class="line">@property (nonatomic, copy) NSMutableArray *mutableArrayOfCopy;</div></pre></td></tr></table></figure>
</li>
</ol>
<p><a href="https://github.com/maligh/ML-Objective-C-Demo/tree/master/Copy-Strong-Array-MutableArray" target="_blank" rel="external">具体运行示例点击查看</a><br>答案是正常应该这样声明<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic, copy) NSArray *arrayOfCopy;</div><div class="line">@property (nonatomic, strong) NSMutableArray *mutableArrayOfStrong;</div></pre></td></tr></table></figure></p>
<h3 id="第七条：在对象内部尽量直接访问实例变量"><a href="#第七条：在对象内部尽量直接访问实例变量" class="headerlink" title="第七条：在对象内部尽量直接访问实例变量"></a>第七条：在对象内部尽量直接访问实例变量</h3><ol>
<li>在类内读取属性的数据时，应该通过直接实例变量来读，这样不经过Objecit-C的方法派发，编译器编译后的代码结果是直接访问存实例变量的那块内存中的值，而不会生成走方法派发的代码，这样的速度会更快。</li>
<li>给属性写入数据时，应该通过属性的方式来写入，这样会调用setter 方法。但是在某种情况下初始化方法以及dealloc方法中，总是应该直接通过实例变量来读写数据，这样做是为了避免子类复写了setter方法造成的异常。</li>
<li>使用了懒加载的属性，应该一直保持用属性的方式来读取写入数据。</li>
</ol>
<h3 id="第八条：理解“对象等同性”这一概念"><a href="#第八条：理解“对象等同性”这一概念" class="headerlink" title="第八条：理解“对象等同性”这一概念"></a>第八条：理解“对象等同性”这一概念</h3><p>思考下面输出什么？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">NSString *aString = @&quot;iphone 8&quot;;</div><div class="line">NSString *bString = [NSString stringWithFormat:@&quot;iphone %i&quot;, 8];</div><div class="line">NSLog(@&quot;%d&quot;, [aString isEqual:bString]);</div><div class="line">NSLog(@&quot;%d&quot;, [aString isEqualToString:bString]);</div><div class="line">NSLog(@&quot;%d&quot;, aString == bString);</div></pre></td></tr></table></figure></p>
<p>答案是110<br><code>==</code>操作符只是比较了两个指针，而不是指针所指的对象</p>
<h3 id="第九条：以“类族模式”隐藏实现细节"><a href="#第九条：以“类族模式”隐藏实现细节" class="headerlink" title="第九条：以“类族模式”隐藏实现细节"></a>第九条：以“类族模式”隐藏实现细节</h3><p>为什么下面这段if 永远为false<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">id maybeAnArray = @[];</div><div class="line">if ([maybeAnArray class] == [NSArray class]) &#123;</div><div class="line">     //Code will never be executed</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>因为[maybeAnArray class] 的返回永远不会是NSArray，NSArray是一个类族，返回的值一直都是NSArray的实体子类。大部分collection类都是某个类族中的’抽象基类’<br>所以上面的if想要有机会执行的话要改成<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">id maybeAnArray = @[];</div><div class="line">    if ([maybeAnArray isKindOfClass [NSArray class]) &#123;</div><div class="line">         //Code probably be executed</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>这样判断的意思是，maybeAnArray这个对象是否是NSArray类族中的一员<br><strong>使用类族的好处：可以把实现细节隐藏再一套简单的公共接口后面</strong></p>
<h3 id="第十条：在既有类中使用关联对象存放自定义数据"><a href="#第十条：在既有类中使用关联对象存放自定义数据" class="headerlink" title="第十条：在既有类中使用关联对象存放自定义数据"></a>第十条：在既有类中使用关联对象存放自定义数据</h3><p>这条讲的是<code>objc_setAssociatedObject</code>和<code>objc_getAssociatedObject</code>,如何使用在这里就不多说了。值得强调的一点是，用关联对象可能会引入难于查找的bug，毕竟是在runtime阶段，所以可能要看情况谨慎选择</p>
<h3 id="第十一条：理解“objc-msgSend”的作用"><a href="#第十一条：理解“objc-msgSend”的作用" class="headerlink" title="第十一条：理解“objc_msgSend”的作用"></a>第十一条：理解“objc_msgSend”的作用</h3><p>之前在<code>了解Objective-C语言的起源</code>有提到过，Objective-C是用的<code>消息结构</code>。这条就是让你理解一下怎么传递的消息。</p>
<ol>
<li>在Objective-C中，如果向某个对象传递消息，那就会在运行时使用动态绑定（dynamic binding）机制来决定需要调用的方法。但是到了底层具体实现，却是普通的C语言函数实现的。这个实现的函数就是<code>objc_msgSend</code>,该函数定义如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void objc_msgSend(id self, SEL cmd, ...)</div></pre></td></tr></table></figure>
</li>
</ol>
<p>这是一个参数个数可变的函数，第一参数代表<code>接收者</code>，第二个参数代表<code>选择子</code>（OC函数名），后续的参数就是消息（OC函数调用）中的那些参数</p>
<ol>
<li>举例来说：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">id return = [git commit:parameter];</div></pre></td></tr></table></figure>
</li>
</ol>
<p>上面的Objective-C方法在运行时会转换成如下函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">id return = objc_msgSend(git, @selector(commit), parameter);</div></pre></td></tr></table></figure></p>
<p>objc_msgSend函数会在接收者所属的类中搜寻其<code>方法列表</code>，如果能找到这个跟选择子名称相同的方法，就跳转到其实现代码，往下执行。若是当前类没找到，那就沿着继承体系继续向上查找，等找到合适方法之后再跳转 ，如果最终还是找不到，那就进入<code>消息转发</code>的流程去进行处理了。</p>
<ol>
<li>说过了OC的函数调用实现，你会觉得消息转发要处理很多，尤其是在搜索上，幸运的是objc_msgSend在搜索这块是有做缓存的，每个OC的类都有一块这样的缓存，objc_msgSend会将匹配结果缓存在<code>快速映射表</code>(fast map)中，这样以来这个类一些频繁调用的方法会出现在fast map 中，不用再去一遍一遍的在<code>方法列表</code>中搜索了。</li>
<li>还有一个有趣的点，就是在底层处理发送消息的时候，有用到<code>尾调用优化</code>，大概原理就是在函数末尾调用某个不含返回值函数时，编译器会自动的不在栈空间上重新进行分配内存，而是直接释放所有调用函数内部的局部变量，然后直接进入被调用函数的地址。</li>
</ol>
<h3 id="第十二条：理解消息转发机制"><a href="#第十二条：理解消息转发机制" class="headerlink" title="第十二条：理解消息转发机制"></a>第十二条：理解消息转发机制</h3><p>关于这条这看看这篇文章：<a href="http://www.jianshu.com/p/f9bd98ad5b05" target="_blank" rel="external">iOS理解Objective-C中消息转发机制附Demo</a></p>
<h3 id="第十三条：用“方法调配技术”调试“黑盒方法”"><a href="#第十三条：用“方法调配技术”调试“黑盒方法”" class="headerlink" title="第十三条：用“方法调配技术”调试“黑盒方法”"></a>第十三条：用“方法调配技术”调试“黑盒方法”</h3><p>这条讲的主要内容就是 Method Swizzling，通过运行时的一些操作可以用另外一份实现来替换掉原有的方法实现，往往被应用在向原有实现中添加新功能，比如扩展UIViewController，在viewDidLoad里面增加打印信息等。具体例子<a href="https://github.com/maligh/ML-OC-Catagory/tree/master/UIViewController%2BHookForLog" target="_blank" rel="external">可以点击我查看</a></p>
<h3 id="第十四条：理解“类对象”的用意"><a href="#第十四条：理解“类对象”的用意" class="headerlink" title="第十四条：理解“类对象”的用意"></a>第十四条：理解“类对象”的用意</h3><p>Objective-C类是由Class类型来表示的，它实际上是一个指向objc_class结构体的指针。它的定义如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">typedef struct objc_class *Class;</div></pre></td></tr></table></figure></p>
<p>在<objc runtime.h="">中能看到他的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">struct objc_class &#123;</div><div class="line">    Class isa  OBJC_ISA_AVAILABILITY;    ///&lt; 指向metaClass(元类)</div><div class="line"></div><div class="line">#if !__OBJC2__</div><div class="line">        Class super_class                       OBJC2_UNAVAILABLE;  ///&lt; 父类</div><div class="line">        const char *name                        OBJC2_UNAVAILABLE;  ///&lt; 类名</div><div class="line">        long version                            OBJC2_UNAVAILABLE;  ///&lt; 类的版本信息，默认为0</div><div class="line">        long info                               OBJC2_UNAVAILABLE;  ///&lt; 类信息，供运行期使用的一些位标识</div><div class="line">        long instance_size                      OBJC2_UNAVAILABLE;  ///&lt; 该类的实例变量大小</div><div class="line">        struct objc_ivar_list *ivars            OBJC2_UNAVAILABLE;  ///&lt; 该类的成员变量链表</div><div class="line">        struct objc_method_list **methodLists   OBJC2_UNAVAILABLE;  ///&lt; 方法定义的链表</div><div class="line">        struct objc_cache *cache                OBJC2_UNAVAILABLE;  ///&lt; 方法缓存</div><div class="line">        struct objc_protocol_list *protocols    OBJC2_UNAVAILABLE;  ///&lt; 协议链表</div><div class="line">#endif</div><div class="line"></div><div class="line">&#125; OBJC2_UNAVAILABLE;</div></pre></td></tr></table></figure></objc></p>
<p>此结构体存放的是类的“元数据”（metadata)，例如类的实例实现了几个方法，具备多少实例变量等信息。<br>这里的isa指针指向的是另外一个类叫做元类（metaClass)。那什么是元类呢？元类是类对象的类。也可以换一种容易理解的说法：</p>
<ol>
<li>当你给对象发送消息时，runtime处理时是在这个对象的类的方法列表中寻找</li>
<li>当你给类发消息时，runtime处理时是在这个类的元类的方法列表中寻找</li>
</ol>
<p>我们来看一个很经典的图来加深理解：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1457495-462fff9ae695d220.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>可以总结为下：</p>
<ol>
<li>每一个<code>Class</code>都有一个<code>isa指针</code>指向一个唯一的<code>Meta Class</code></li>
<li>每一个<code>Meta Class</code>的<code>isa指针</code>都指向最上层的<code>Meta Class</code>，这个<code>Meta Class</code>是<code>NSObject的Meta Class</code>。(包括<code>NSObject的Meta Class</code>的<code>isa指针</code>也是指向的<code>NSObject的Meta Class</code>，也就是自己，这里形成了个闭环)</li>
<li>每一个<code>Meta Class</code>的<code>super class</code>指针指向它<code>原本Class</code>的 <code>Super Class的Meta Class</code> (这里最上层的<code>NSObject的Meta Class</code>的<code>super class</code>指针还是指向自己)</li>
<li>最上层的<code>NSObject Class的super class</code>指向 nil</li>
</ol>
<h2 id="第三章：接口与API设计"><a href="#第三章：接口与API设计" class="headerlink" title="第三章：接口与API设计"></a>第三章：接口与API设计</h2><h3 id="第十五条：用前缀避免命名空间冲突"><a href="#第十五条：用前缀避免命名空间冲突" class="headerlink" title="第十五条：用前缀避免命名空间冲突"></a>第十五条：用前缀避免命名空间冲突</h3><p>Objective-C没有类似其他语言那样的命名空间机制(namespace)，比如说PHP中的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">namespace Root\Sub\subnamespace;</div></pre></td></tr></table></figure></p>
<p>这就会导致当你不小心实现了两个相同名字的类，或者把两个相对独立的库导入项目时而他们又恰好有重名的类的时候该类所对应的符号和Meta Class符号定义了两次。所以很容易产生这种命名冲突，让程序的链接过程中出现出现重复的符号造成报错。<br>为了避免这种情况，我们要尽量在类名，以及分类和分类方法上增加前缀，还有一些宏定义等等根据自己项目来定吧</p>
<h3 id="第十六条：提供“全能初始化方法”"><a href="#第十六条：提供“全能初始化方法”" class="headerlink" title="第十六条：提供“全能初始化方法”"></a>第十六条：提供“全能初始化方法”</h3><p>如果创建类的实例的方式不止一种，那么这个类就会有多个初始化方法，这样做很好，不过还是要在其中选定一个方法作为全能初始化方法，剩下的其余的初始化方法都要调用它，这样做的好处是以后如果初始化的逻辑更改了只需更改一处即可，或者是交给子类覆写的时候也只覆写这一个方法即可~<br>举个例子来说:可以看一下NSDate的实现在NSDate.h中NSDate类中定义了一个全能初始化方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (instancetype)initWithTimeIntervalSinceReferenceDate:(NSTimeInterval)ti NS_DESIGNATED_INITIALIZER;</div></pre></td></tr></table></figure></p>
<p>其余的类似初始化方式定义在NSDate (NSDateCreation) 分类中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (instancetype)initWithTimeIntervalSinceNow:(NSTimeInterval)secs;</div><div class="line">- (instancetype)initWithTimeIntervalSince1970:(NSTimeInterval)secs;</div><div class="line">- (instancetype)initWithTimeInterval:(NSTimeInterval)secsToBeAdded sinceDate:(NSDate *)date;</div></pre></td></tr></table></figure></p>
<p>在NSDate文档中有一条：<code>If you want to subclass NSDate to obtain behavior different than that provided by the private or public subclasses, you must do these things:</code>然后其中要做的有一步就是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Override [initWithTimeIntervalSinceReferenceDate:</div><div class="line">](apple-reference-documentation://hcslylvSCo), one of the designated initializer methods`</div></pre></td></tr></table></figure></p>
<p><strong>这个是我们组织代码过程中应该学习的地方！</strong></p>
<h3 id="第十七条：实现description方法"><a href="#第十七条：实现description方法" class="headerlink" title="第十七条：实现description方法"></a>第十七条：实现description方法</h3><p>这条讲的是可以通过覆写description方法或者debugDescription方法来在NSLog打印时或者LLDB打印时输出更多的自定义信息。(数据和字典的可以通过覆写<code>descriptionWithLocale:</code>方法)<br>友情提示：不要在description中使用 <code>NSLog(&quot;%@&quot;,self);</code>，不然会掉进无底深渊啊<br>这里我有一个有趣的想法，不过还没完全实现，就是想通过覆写description能把任何一个对象的属性值名称，属性值都一一完整的记录下来，<a href="https://github.com/maligh/ML-Objective-C-Demo/tree/master/MLDescription" target="_blank" rel="external">可以点击查看</a></p>
<h3 id="第十八条：尽量使用不可变对象"><a href="#第十八条：尽量使用不可变对象" class="headerlink" title="第十八条：尽量使用不可变对象"></a>第十八条：尽量使用不可变对象</h3><p>这条主要讲尽量使用不可变的对象，也就是在对外属性声明的时候要尽量加上readonly修饰，默认是readwrite，这样一来，在外部就只能读取该数据，而不能修改它，使得这个类的实例所持有的数据更加安全。如果外部想要修改，可以提供方法来进行修改。<br>不要把可变的collection作为属性公开，而应提供相关方法，以此修改对象中的可变collection(这条个人感觉一般在常用、重要的类才有必要，毕竟也增加了不少代码量)<br>比如例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//Language.h</div><div class="line">@property (nonatomic, strong) NSSet *set;</div></pre></td></tr></table></figure></p>
<p>应该改为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">//Language.h</div><div class="line">@property (nonatomic, strong, readonly) NSSet *languages;</div><div class="line">- (void)addLanguage:(NSString *)language;</div><div class="line">- (void)removeLanguage:(NSString *)language;</div><div class="line">//**.m</div><div class="line">@implementation Language &#123;</div><div class="line">    NSMutableSet *mutableLanguages;</div><div class="line">&#125;</div><div class="line">- (NSSet *)languages &#123;</div><div class="line">    return [_mutableLanguages copy];</div><div class="line">&#125;</div><div class="line">- (void)addLanguage:(NSString *)language &#123;</div><div class="line">    [_mutableLanguages addObject:language];</div><div class="line">&#125;</div><div class="line">- (void)removeLanguage:(NSString *)language &#123;</div><div class="line">     [_mutableLanguages removeObject:language];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="第十九条：使用清晰而协调的命名方式"><a href="#第十九条：使用清晰而协调的命名方式" class="headerlink" title="第十九条：使用清晰而协调的命名方式"></a>第十九条：使用清晰而协调的命名方式</h3><p>这条不用太强调了，具体也可以参照一下我之前拟的<a href="http://www.jianshu.com/p/bbb0b57eb168" target="_blank" rel="external">Objective-C编程规范及建议</a>，后续可能会不断补充更新</p>
<h3 id="第二十条：为私有方法名加前缀"><a href="#第二十条：为私有方法名加前缀" class="headerlink" title="第二十条：为私有方法名加前缀"></a>第二十条：为私有方法名加前缀</h3><p>这条讲的是应该为类内的私有方法增加前缀，以便区分，这个感觉因人而异吧，感觉只要你不随便把私有方法暴露在.h文件都能接受，曾遇到过这样的同事，感觉其不太适合写程序吧。</p>
<h3 id="第二十一条：理解Objective-C错误模型"><a href="#第二十一条：理解Objective-C错误模型" class="headerlink" title="第二十一条：理解Objective-C错误模型"></a>第二十一条：理解Objective-C错误模型</h3><p>很多语言都有异常处理机制，Objective-C也不例外，Objective-C也有类似的@throw，不过在OC中使用@throw可能会导致内存泄漏，可能是它被设计的使用场景的问题。建议@throw只用来处理严重错误，也可以理解为致命错误(fatal error)，那么处理一般错误的时候（nonfatal error）时可以使用NSError。</p>
<h3 id="第二十二条：理解NSCopying协议"><a href="#第二十二条：理解NSCopying协议" class="headerlink" title="第二十二条：理解NSCopying协议"></a>第二十二条：理解NSCopying协议</h3><p>在OC开发中，使用对象时经常需要拷贝它，我们会通过<code>copy/mutbleCopy</code>来完成。如果想让自己的类支持拷贝，那必须要实现<code>NSCopying</code>协议，只需要实现一个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (id)copyWithZone:(NSZone*)zone</div></pre></td></tr></table></figure></p>
<p>当然如果要求返回对象是可变的类型就要用到<code>NSMutableCopying</code>协议，相应方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (id)mutableCopyWithZone:(NSZone *)zone</div></pre></td></tr></table></figure></p>
<p>在拷贝对象时，需要注意拷贝执行的是浅拷贝还是深拷贝。深拷贝在拷贝对象时，会将对象的底层数据也进行了拷贝。浅拷贝是创建了一个新的对象指向要拷贝的内容。一般情况应该尽量执行浅拷贝。</p>
<hr>
<h2 id="第四章：协议与分类"><a href="#第四章：协议与分类" class="headerlink" title="第四章：协议与分类"></a>第四章：协议与分类</h2><h3 id="第二十三条：通过委托与数据源协议进行对象间通信"><a href="#第二十三条：通过委托与数据源协议进行对象间通信" class="headerlink" title="第二十三条：通过委托与数据源协议进行对象间通信"></a>第二十三条：通过委托与数据源协议进行对象间通信</h3><p>这条讲的也比较基础，就是基本的delegate，protocal使用。<br>有一点稍微说一下：当某对象需要从另外一个对象中获取数据时，可以使用委托模式，这种用法经常被称为“数据源协议”（Data source Protocal）类似 <code>UITableview</code>的<code>UITableViewDataSource</code><br>另外在Swift中有一个很重要的思想就是面向协议编程。当然OC中也可以用协议来降低代码耦合性，必要的时候也可以替代继承，因为遵循同一个协议的类可以是任何，不必是同一个继承体系下。</p>
<h3 id="第二十四条：将类的实现代码分散到便于管理的数个分类之中"><a href="#第二十四条：将类的实现代码分散到便于管理的数个分类之中" class="headerlink" title="第二十四条：将类的实现代码分散到便于管理的数个分类之中"></a>第二十四条：将类的实现代码分散到便于管理的数个分类之中</h3><p>这条主要说的是通过分类机制，可以把类分成很多歌易于管理的小块。也是有一些前提的吧，可能是这个类业务比较复杂，需要瘦身，需要解耦等等。作者还推荐把私有方法统一放在Private分类中，以隐藏实现细节。这个个人觉得视情况而定吧。</p>
<h3 id="第二十五条：总是为第三方类的分类名称加前缀"><a href="#第二十五条：总是为第三方类的分类名称加前缀" class="headerlink" title="第二十五条：总是为第三方类的分类名称加前缀"></a>第二十五条：总是为第三方类的分类名称加前缀</h3><p>向第三方类的分类名称加上你专用的前缀，这点不必多说，😜</p>
<h3 id="第二十六条：勿在分类中声明属性"><a href="#第二十六条：勿在分类中声明属性" class="headerlink" title="第二十六条：勿在分类中声明属性"></a>第二十六条：勿在分类中声明属性</h3><p>不要在分类中声明属性，除了“class-continuation”分类中。那什么是“class-continuation”分类呢，其实就是我们经常在.m文件中用到的，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//Swift.m </div><div class="line">@interface Swift () </div><div class="line">//这个就是“class-continuation”分类</div><div class="line">@end</div><div class="line">@implementation Swift</div><div class="line">@end</div></pre></td></tr></table></figure></p>
<h3 id="第二十七条：使用“class-continuation”分类隐藏实现细节"><a href="#第二十七条：使用“class-continuation”分类隐藏实现细节" class="headerlink" title="第二十七条：使用“class-continuation”分类隐藏实现细节"></a>第二十七条：使用“class-continuation”分类隐藏实现细节</h3><p>这条跟之前的也有点重复，最终目的还是要尽量在公共接口中向外暴露的内容最小化，隐藏实现细节，只告诉怎么调用，怎么使用即可。具体实现以及属性的可修改权限尽可能的隐藏掉。</p>
<h3 id="第二十八条：通过协议提供匿名对象"><a href="#第二十八条：通过协议提供匿名对象" class="headerlink" title="第二十八条：通过协议提供匿名对象"></a>第二十八条：通过协议提供匿名对象</h3><ol>
<li>协议可以在某种程度上提供匿名对象，例如<code>id&lt;someProtocal&gt; object</code>。object对象的类型不限，只要能遵从这个协议即可，在这个协议里面定义了这个对象所应该实现的方法。</li>
<li>如果具体类型不重要，重要的是对象能否处理好一些特定的方法，那么就可以使用这种协议匿名对象来完成。</li>
</ol>
<hr>
<h2 id="第五章：内存管理"><a href="#第五章：内存管理" class="headerlink" title="第五章：内存管理"></a>第五章：内存管理</h2><h3 id="第二十九条：理解引用计数"><a href="#第二十九条：理解引用计数" class="headerlink" title="第二十九条：理解引用计数"></a>第二十九条：理解引用计数</h3><ol>
<li>理解引用计数这个可以通过《Objective-C 高级编程》这本书中的例子来理解，比较直观，大概如下：</li>
</ol>
<p><img src="http://upload-images.jianshu.io/upload_images/1457495-a2a2c38354a2af20.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<table>
<thead>
<tr>
<th>对照明设备所做的工作</th>
<th>对OC对象所做的动作</th>
</tr>
</thead>
<tbody>
<tr>
<td>开灯</td>
<td>生成对象</td>
</tr>
<tr>
<td>需要照明</td>
<td>持有</td>
</tr>
<tr>
<td>不需要照明</td>
<td>释放</td>
</tr>
<tr>
<td>关灯</td>
<td>废弃</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>内存管理的思考方式</th>
<th>对应OC方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>自己生成的对象，自己所持有</td>
<td>alloc/new/copy/mutableCopy等</td>
</tr>
<tr>
<td>非自己生成的对象(比如[NSArray array])，自己也能持有</td>
<td>retain </td>
</tr>
<tr>
<td>不再需要自己持有的对象时释放</td>
<td>release</td>
</tr>
<tr>
<td>当对象不被任何其他对象持有时废弃</td>
<td>dealloc</td>
</tr>
</tbody>
</table>
<ol>
<li>自动释放池: 可以看到在我们程序中入口文件main.m中main函数中就包裹了一层autoreleasepool<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">int main(int argc, char * argv[]) &#123;</div><div class="line">    @autoreleasepool &#123;</div><div class="line">        return UIApplicationMain(argc, argv, nil, NSStringFromClass([HSAppDelegate class]));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>autoreleasepool可以延长对象的生命期，使其在跨越方法调用边界后依然可以存活一段时间，通常是在下一次“时间循环”（event loop）时释放，不过也可能会执行的早一点。</p>
<ol>
<li>保留环: 也称retain cycle，就是循环引用。形成原因就是对象之间相互用强引用指向对方，会使得全部都无法得以释放。解决方案通常是使用弱引用（weak reference)</li>
</ol>
<h3 id="第三十条：以ARC简化引用计数"><a href="#第三十条：以ARC简化引用计数" class="headerlink" title="第三十条：以ARC简化引用计数"></a>第三十条：以ARC简化引用计数</h3><p>使用ARC，可以省略对于引用计数的操作，所以在ARC下调用对象的retain，release，autorelease，dealloc方法时系统会报错。<br>这里要注意CoreFoundation 对象不归ARC管理，开发中如果有用到还是要谁创建谁释放，适时调用CFRetain/CFRelease。</p>
<h3 id="第三十一条：在delloc方法中只释放引用并解除监听"><a href="#第三十一条：在delloc方法中只释放引用并解除监听" class="headerlink" title="第三十一条：在delloc方法中只释放引用并解除监听"></a>第三十一条：在delloc方法中只释放引用并解除监听</h3><p>不要在delloc方法中调用其他方法，尤其是需要异步执行某些任务又要回调的方法，这样的很危险的行为，很可能异步执行完回调的时候该对象已经被销毁了，这样就没得玩了，crash了。<br>在delloc方法里应该制作一些释放相关的事情，包括不限于一些KVO取消订阅，remove 通知等。</p>
<h3 id="第三十二条：编写“异常安全代码”时留意内存管理问题"><a href="#第三十二条：编写“异常安全代码”时留意内存管理问题" class="headerlink" title="第三十二条：编写“异常安全代码”时留意内存管理问题"></a>第三十二条：编写“异常安全代码”时留意内存管理问题</h3><p>这条有点重复，之前已经说过了，OC中抛出异常的时候可能会引起内存泄漏，注意一下使用的时机，或者注意在@try捕获异常中清理干净。</p>
<h3 id="第三十三条：以弱引用避免保留环"><a href="#第三十三条：以弱引用避免保留环" class="headerlink" title="第三十三条：以弱引用避免保留环"></a>第三十三条：以弱引用避免保留环</h3><p>这条比较简单，内容主旨就是标题：以弱引用避免保留环(Retain Cycle)</p>
<h3 id="第三十四条：以“-autoreleasepool”降低内存峰值"><a href="#第三十四条：以“-autoreleasepool”降低内存峰值" class="headerlink" title="第三十四条：以“@autoreleasepool”降低内存峰值"></a>第三十四条：以“@autoreleasepool”降低内存峰值</h3><p>在遍历处理一些大数组或者大字典的时候，可以使用自动释放池来降低内存峰值，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">NSArray *people = /*一个很大的数组*/</div><div class="line">NSMutableArray *employeesArray = [NSMutableArray new];</div><div class="line">for (NSStirng *name in people) &#123;</div><div class="line">    @autoreleasepool &#123;</div><div class="line">        MLEmployee *employee = [MLEmployee alloc] initWithName:name];</div><div class="line">        [employeesArray addObject:employee];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="第三十五条：用“僵尸对象”调试内存管理问题"><a href="#第三十五条：用“僵尸对象”调试内存管理问题" class="headerlink" title="第三十五条：用“僵尸对象”调试内存管理问题"></a>第三十五条：用“僵尸对象”调试内存管理问题</h3><p><img src="http://upload-images.jianshu.io/upload_images/1457495-586f50d111cab802.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>如上图，勾选这里可以开启僵尸对象设置。开启之后，系统在回收对象时，不将其真正的回收，而是把它的isa指针指向特殊的僵尸类，变成僵尸对象。僵尸类能够响应所有的选择子，响应方式为：打印一条包含消息内容以及其接收者的消息，然后终止应用程序</p>
<h3 id="第三十六条：不要使用retainCount"><a href="#第三十六条：不要使用retainCount" class="headerlink" title="第三十六条：不要使用retainCount"></a>第三十六条：不要使用retainCount</h3><p>在苹果引入ARC之后retainCount已经正式废弃，任何时候都不要调用这个retainCount方法来查看引用计数了，因为这个值实际上已经没有准确性了。但是在MRC下还是可以正常使用</p>
<hr>
<h2 id="第六章：Block与GCD"><a href="#第六章：Block与GCD" class="headerlink" title="第六章：Block与GCD"></a>第六章：Block与GCD</h2><h3 id="第三十七条：理解block"><a href="#第三十七条：理解block" class="headerlink" title="第三十七条：理解block"></a>第三十七条：理解block</h3><p>根据block在内存中的位置，block被分成三种类型：</p>
<ol>
<li><p>NSGlobalBlock 全局块:<br>这种块运行时无需获取外界任何状态，块所使用的内存区域在编译器就可以完全确定，所以该块声明在全局内存中。如果全局块执行copy会是一个空操作，相当于什么都没做。全局块例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">void (^block)() = ^&#123;</div><div class="line">    NSLog(@&quot;I am a NSGlobalBlock&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>NSStackBlock  栈块:<br>栈块保存于栈区，超出变量作用域，栈上的block以及__block变量都会被销毁。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">NSString *name = @&quot;PHP&quot;;</div><div class="line">void (^block)() = ^&#123;</div><div class="line">    NSLog(@&quot;世界上最好的编程语言是%@&quot;, name);</div><div class="line">&#125;;</div><div class="line">NSLog(@&quot;%@&quot;, block);</div></pre></td></tr></table></figure>
</li>
</ol>
<p>运行下你会发现控制台打印的是:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;__NSStackBlock__: 0x7fff5480fa18&gt;</div></pre></td></tr></table></figure></p>
<p>什么，你说什么，你打印出来的是<code>__ NSMallocBlock __</code>? 那是因为你在ARC下编译的，ARC下编译器编译时会帮你优化自动帮你加上了copy操作，你可以用<code>-fno-objc-arc</code>关闭ARC再看一下</p>
<ol>
<li>NSMallocBlock  堆块:<br><em>NSMallocBlock内心独白：我已经被暴露了，为什么要最后才介绍我！！</em><br>堆block内存保存于堆区，在变量作用域结束时不受影响。通过之前在ARC下的输出已经看到了<strong> NSMallocBlock </strong>.所以我们在定义block类型的属性时常常加上copy修饰，这个修饰其实是多余的，系统在ARC的时候已经帮我们做了copy，但是还是建议写上copy。</li>
</ol>
<h3 id="第三十八条：为常用的块类型创建typedef"><a href="#第三十八条：为常用的块类型创建typedef" class="headerlink" title="第三十八条：为常用的块类型创建typedef"></a>第三十八条：为常用的块类型创建typedef</h3><p>这条主要是为了代码更易读，也比较重要。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (void)getDataWithHost:(NSString *)host success:(void (^)(id responseDic))success;</div><div class="line">//以上要改成下面这种</div><div class="line">typedef void (^SuccessBlock)(id responseDic);</div><div class="line">- (void)getDataWithHost:(NSString *)host success:(SuccessBlock)success;</div></pre></td></tr></table></figure></p>
<h3 id="第三十九条：用handler块降低代码分散程度"><a href="#第三十九条：用handler块降低代码分散程度" class="headerlink" title="第三十九条：用handler块降低代码分散程度"></a>第三十九条：用handler块降低代码分散程度</h3><p>在iOS开发中，我们经常需要异步执行一些任务，然后等待任务执行结束之后通知相关方法。实现此需求的做法很多，比如说有些人可能会选择用委托协议。那么在这种异步执行一些任务，然后等待执行结束之后调用代理的时候，可能代码就会比较分散。当多个任务都需要异步，等等就显得比较不那么合理了。<br>所以我们可以考虑使用block的方式设计，这样业务相关的代码会比较紧凑，不会显得那么凌乱。</p>
<h3 id="第四十条：用块引用其所属对象是不要出现保留环"><a href="#第四十条：用块引用其所属对象是不要出现保留环" class="headerlink" title="第四十条：用块引用其所属对象是不要出现保留环"></a>第四十条：用块引用其所属对象是不要出现保留环</h3><p>这点比较基础了，但是要稍微说一下，不是一定得在block中使用weakself，比如下面：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[YTKNetwork requestBlock:^(id responsObject) &#123;</div><div class="line">      NSLog(@&quot;%@&quot;,self.name);</div><div class="line">  &#125;];</div></pre></td></tr></table></figure></p>
<p>block 不是被self所持有的，在block中就可以使用self</p>
<h3 id="第四十一条：多用派发队列，少用同步锁"><a href="#第四十一条：多用派发队列，少用同步锁" class="headerlink" title="第四十一条：多用派发队列，少用同步锁"></a>第四十一条：多用派发队列，少用同步锁</h3><p>在iOS开发中，如果有多个线程要执行同一份代码，我们可能需要加锁来实现某种同步机制。有人可能第一印象想到的就是<code>@synchronized(self)</code>，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">- (NSString*)someString &#123;</div><div class="line">    @synchronized(self) &#123;</div><div class="line">        return _someString;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">- (void)setSomeString:(NSString*)someString &#123;</div><div class="line">     @synchronized(self) &#123;</div><div class="line">        _someString = someString;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样写法效率很低，而且也不能保证线程中觉得的安全。如果有很多属性，那么每个属性的同步块都要等其他同步块执行完毕才能执行。<br>应该用GCD来替换：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">_syncQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</div><div class="line"></div><div class="line">//读取字符串</div><div class="line">- (NSString*)someString &#123;</div><div class="line">    __block NSString *localSomeString;</div><div class="line">     dispatch_sync(_syncQueue, ^&#123;</div><div class="line">        localSomeString = _someString;</div><div class="line">    &#125;);</div><div class="line">     return localSomeString;</div><div class="line">&#125;</div><div class="line">- (void)setSomeString:(NSString*)someString &#123;</div><div class="line">     dispatch_barrier_async(_syncQueue, ^&#123;</div><div class="line">        _someString = someString;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="第四十二条：多用GCD，少用performSelector系列方法"><a href="#第四十二条：多用GCD，少用performSelector系列方法" class="headerlink" title="第四十二条：多用GCD，少用performSelector系列方法"></a>第四十二条：多用GCD，少用performSelector系列方法</h3><p>Objective-C本质上是一门分厂动态的语言，开发者在开发中可以指定任何一个方法去调用，也可以延迟调用一些方法，或者指定运行方法的线程。一般我们会想到<code>performSelector</code>，但是在GCD出来之后基本就没那么需要<code>performSelector</code>了，<code>performSelector</code>也有很多缺点：</p>
<ol>
<li>内存管理问题：在ARC下使用<code>performSelector</code>我们经常会看到编译器发出如下警告：<code>warning: performSelector may cause a leak because its selector is unknown [-Warc-performSelector-leaks]</code></li>
<li><code>performSelector</code>的返回值只能是void或对象类型。</li>
<li><code>performSelector</code>无法处理带有多个参数的选择子，最多只能处理两个参数。<br>为了改变这些，我们可以用下面这种方式</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">        [self doSomething];</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>替换掉<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[self performSelectorOnMainThread:@selector(doSomething) </div><div class="line">                       withObject:nil </div><div class="line">                    waitUntilDone:NO];</div></pre></td></tr></table></figure></p>
<p>然后还可以用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, </div><div class="line">                                (int64_t)(5.0 * NSEC_PER_SEC));</div><div class="line">dispatch_after(time, dispatch_get_main_queue(), ^(void)&#123;</div><div class="line">    [self doSomething];</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>替换<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[self performSelector:@selector(doSomething) </div><div class="line">           withObject:nil </div><div class="line">           afterDelay:5.0];</div></pre></td></tr></table></figure></p>
<h3 id="第四十三条：掌握GCD以及操作队列的使用时机"><a href="#第四十三条：掌握GCD以及操作队列的使用时机" class="headerlink" title="第四十三条：掌握GCD以及操作队列的使用时机"></a>第四十三条：掌握GCD以及操作队列的使用时机</h3><p>GCD技术确实很棒，但是也有一些局限性，或者说有一些场景并不适合。比如过想取消队列中的某个操作，或者需要后台执行任务。还有一种技术叫<code>NSOperationQueue</code>，其实<code>NSOperationQueue</code>跟GCD有很多相像之处。<code>NSOperationQueue</code>在GCD之前就已经有了，GCD就是在其某些原理上构建的。GCD是C层次的API，而<code>NSOperation</code>是重量级的Objective-C对象。<br>使用<code>NSOperation</code>和<code>NSOperationQueue</code>的优点：</p>
<ol>
<li>支持取消某个操作：在运行任务前，可以在NSOperation对象上调用<code>cancel方法</code>，用以表明此任务不需要执行。不过已经启动的任务无法取消。GCD队列是无法取消的，GCD是“安排好之后就不管了（fire and forget）”。</li>
<li>支持指定操作间的依赖关系：一个操作可以依赖其他多个操作，例如从服务器下载并处理文件的动作可以用操作来表示，而在处理其他文件之前必须先下载“清单文件”。而后续的下载工作，都要依赖于先下载的清单文件这一操作。这时如果操作队列允许并发执行的话，后续的下载操作就可以在他依赖的<code>下载清单文件操作</code>执行完毕之后开始同时执行。</li>
<li>支持通过KVO监控NSOperation对象的属性：可以通过isCancelled属性来判断任务是否已取消，通过isFinished属性来判断任务是否已经完成等等。</li>
<li>支持指定操作的优先级：操作的优先级表示此操作与队列中其他操作之间的优先关系，优先级搞的操作先执行，优先级低的后执行。GCD的队列也有优先级，不过不是针对整个队列的。</li>
<li>重用NSOperation对象。在开发中你可以使用NSOperation的子类或者自己创建NSOperation对象来保存一些信息，可以在类中定义方法，使得代码能够多次使用。不必重复自己。</li>
</ol>
<h3 id="第四十四条：通过Dispatch-Group机制，根据系统资源状况来执行任务"><a href="#第四十四条：通过Dispatch-Group机制，根据系统资源状况来执行任务" class="headerlink" title="第四十四条：通过Dispatch Group机制，根据系统资源状况来执行任务"></a>第四十四条：通过Dispatch Group机制，根据系统资源状况来执行任务</h3><p>这条主要是介绍dispatch group，任务分组的功能。他可以把任务分组，然后等待这组任务执行完毕时会有通知，开发者可以拿到结果然后继续下一步操作。<br>另外通过dispatch group在并发队列上同时执行多项任务的时候，GCD会根据系统资源状态来帮忙调度这些并发执行的任务。</p>
<h3 id="第四十五条：使用dispatch-once来执行只需要运行一次的线程安全代码"><a href="#第四十五条：使用dispatch-once来执行只需要运行一次的线程安全代码" class="headerlink" title="第四十五条：使用dispatch_once来执行只需要运行一次的线程安全代码"></a>第四十五条：使用dispatch_once来执行只需要运行一次的线程安全代码</h3><p>这条讲的是常用的dispatch_once<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">+ (id)sharedInstance &#123;</div><div class="line">     static EOCClass *sharedInstance = nil;</div><div class="line">     static dispatch_once_t onceToken;</div><div class="line">     dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">﻿            sharedInstance = [[self alloc] init];</div><div class="line">    &#125;);</div><div class="line">     return sharedInstance;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>dispatch_once比较高效，没有重量级的同步机制。</p>
<h3 id="第四十六条：不要使用dispatch-get-current-queue"><a href="#第四十六条：不要使用dispatch-get-current-queue" class="headerlink" title="第四十六条：不要使用dispatch_get_current_queue"></a>第四十六条：不要使用dispatch_get_current_queue</h3><ol>
<li>dispatch_get_current_queue 函数的行为常常与开发者所预期的不同，此函数已经废弃，只应做调试之用。</li>
<li>由于GCD是按层级来组织的，所以无法单用某个队列对象来描述”当前队列”这一概念。</li>
<li>dispatch_get_current_queue 函数用于解决由不可以重入的代码所引发的死锁，然后能用此函数解决的问题，通常也可以用”队列特定数据”来解决。</li>
</ol>
<hr>
<h2 id="第七章：系统框架"><a href="#第七章：系统框架" class="headerlink" title="第七章：系统框架"></a>第七章：系统框架</h2><h3 id="第四十七条：熟悉系统框架"><a href="#第四十七条：熟悉系统框架" class="headerlink" title="第四十七条：熟悉系统框架"></a>第四十七条：熟悉系统框架</h3><p>在Objective-C中除了Foundation 与CoreFoundation之外还有很多系统库，其中包括但不限于下面列出的这些：</p>
<ol>
<li>CFNetwork:此框架提供了C语言级别的网络通信能力，它将BSD socket抽象成了易于使用的网络接口。而Foundation则将该框架里的部分内容封装为Objective-C接口，以便进行网络通信。</li>
<li>CoreAudio:此框架所提供的C语言API可以用来操作设备上的音频硬件。</li>
<li>AVFoundation:此框架所提供的Objective-C对象可用来回访并录制音频及视频，比如能够在UI视图类里播放视频。</li>
<li>CoreData:此框架所提供的Objective-C接口可以将对象放入数据库，将数据持久化。</li>
<li>CoreText:此框架提供的C语言接口可以高效执行文字排版以及渲染操作。</li>
<li>SpriteKit :游戏框架</li>
<li>CoreLocation、MapKit :定位地图相关框架</li>
<li>Address Book框架:需要使用通讯录时才使用该框架</li>
<li>Music Libraries框架:音乐库相关框架</li>
<li>HealthKit框架：健康相关框架</li>
<li>HomeKit框架：为智能化硬件提供的框架</li>
<li>CloudKit : iCloud相关的框架</li>
<li>Passbook、PassKit框架：为了在应用中用户可以很容易的访问他们之前购买的活动门票、旅行车票、优惠券等等提供的框架</li>
</ol>
<h3 id="第四十八条：多用块枚举，少用for循环"><a href="#第四十八条：多用块枚举，少用for循环" class="headerlink" title="第四十八条：多用块枚举，少用for循环"></a>第四十八条：多用块枚举，少用for循环</h3><ol>
<li>遍历collection中的元素有四种方式，最基本的办法就是for循环，其次是NSEnumerator遍历法，还有快速遍历法（for in），以及块枚举法。块枚举是最新，最先进的方式。</li>
<li>块枚举法是通过GCD来并发执行遍历操作</li>
<li>若提前知道待遍历的collection含有何种对象，则应修改块签名，指出对象的具体类型。</li>
</ol>
<h3 id="第四十九条：对自定义其内存管理语义的collecion使用无缝桥接"><a href="#第四十九条：对自定义其内存管理语义的collecion使用无缝桥接" class="headerlink" title="第四十九条：对自定义其内存管理语义的collecion使用无缝桥接"></a>第四十九条：对自定义其内存管理语义的collecion使用无缝桥接</h3><p>通过无缝桥接技术，可以在定义于Foundation框架中的类和CoreFoundation框架中的C语言数据结构之间来回转换。<br>下面代码展示了简单的无缝桥接：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">NSArray *anNSArray = @[@1, @2, @3, @4, @5];</div><div class="line">CFArrayRef aCFArray = (__bridge CFArrayRef)anNSArray;</div><div class="line">NSLog(@&quot;Size of array = %li&quot;, CFArrayGetCount(aCFArray));</div><div class="line">//Output: Size of array = 5</div></pre></td></tr></table></figure></p>
<p>转换操作中的<code>__bridge</code>告诉ARC如何传力转换所涉及的OC对象，也就是ARC仍然具备这个OC对象的所有权。<code>__bridge_retained</code>与之相反。这里要注意用完了数组要自己释放，使用<code>CFRelease(aCFArray)</code>前面有提到过的。</p>
<h3 id="第五十条：构建缓存时选用NSCache而非NSDictionary"><a href="#第五十条：构建缓存时选用NSCache而非NSDictionary" class="headerlink" title="第五十条：构建缓存时选用NSCache而非NSDictionary"></a>第五十条：构建缓存时选用NSCache而非NSDictionary</h3><p>在构建缓存时应该尽量选用NSCache而非NSDictionary，NSCache会在系统资源将要耗尽时自动删减缓存，而使用NSDictionary只能通过系统低内存警告方法去手动处理。此外NSCache还会看情况删减最久未使用的对象，而且是线程安全的。</p>
<h3 id="第五十一条：精简initialize与load的实现代码"><a href="#第五十一条：精简initialize与load的实现代码" class="headerlink" title="第五十一条：精简initialize与load的实现代码"></a>第五十一条：精简initialize与load的实现代码</h3><ol>
<li>load与initialize 方法都应该实现的精简一点，这样有助于保持应用程序的响应能力，也可以减少引入依赖环的几率</li>
<li>无法在编译器设定的全局常量，可以放在initialize方法里面初始化。<br>另外没搞清楚load 与 initialize的可以看这里， 我之前有出过一道有点脑残有点绕的题（别拍砖，😆），<a href="http://www.jianshu.com/p/ffdefa76e4a2" target="_blank" rel="external">可以点击这里查看</a></li>
</ol>
<h3 id="第五十二条：别忘了NSTimer会保留其目标对象"><a href="#第五十二条：别忘了NSTimer会保留其目标对象" class="headerlink" title="第五十二条：别忘了NSTimer会保留其目标对象"></a>第五十二条：别忘了NSTimer会保留其目标对象</h3><p>在iOS开发中经常会用到定时器:NSTimer，由于NSTimer会生成指向其使用者的引用，而其使用者如果也引用了NSTimer，那就形成了该死的循环引用，比如下面这个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@interface EOCClass : NSObject</div><div class="line">- (void)startPolling;</div><div class="line">- (void)stopPolling;</div><div class="line">@end</div><div class="line">@implementation EOCClass &#123;</div><div class="line">     NSTimer *_pollTimer;</div><div class="line">&#125;</div><div class="line">- (id)init &#123;</div><div class="line">     return [super init];</div><div class="line">&#125;</div><div class="line">- (void)dealloc &#123;</div><div class="line">    [_pollTimer invalidate];</div><div class="line">&#125;</div><div class="line">- (void)stopPolling &#123;</div><div class="line"></div><div class="line">    [_pollTimer invalidate];</div><div class="line">    _pollTimer = nil;</div><div class="line">&#125;</div><div class="line">- (void)startPolling &#123;</div><div class="line">   _pollTimer = [NSTimer scheduledTimerWithTimeInterval:5.0</div><div class="line">                                                 target:self</div><div class="line">                                               selector:@selector(p_doPoll)</div><div class="line">                                               userInfo:nil</div><div class="line">                                                repeats:YES];</div><div class="line">&#125;</div><div class="line">- (void)p_doPoll &#123;</div><div class="line">    // Poll the resource</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>如果创建了本类的实例，并调用其startPolling方法开始定时器，由于目标对象是self，所以要保留此实例，因为定时器是用成员变量存放的，所以self也保留了计时器，所以此时存在保留环。此时要么调用<code>stopPolling</code>，要么令系统将此实例回收，只有这样才能打破保留环。<br>这是一个很常见的内存泄漏，那么怎么解决呢？这个问题可以通过block来解决。可以添加这样的一个分类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line">//.h</div><div class="line">@interface NSTimer (EOCBlocksSupport)</div><div class="line"></div><div class="line">+ (NSTimer*)eoc_scheduledTimerWithTimeInterval:(NSTimeInterval)interval</div><div class="line">                                         block:(void(^)())block</div><div class="line">                                         repeats:(BOOL)repeats;</div><div class="line">@end</div><div class="line">//.m</div><div class="line">@implementation NSTimer (EOCBlocksSupport)</div><div class="line"></div><div class="line">+ (NSTimer*)eoc_scheduledTimerWithTimeInterval:(NSTimeInterval)interval</div><div class="line">                                         block:(void(^)())block</div><div class="line">                                        repeats:(BOOL)repeats</div><div class="line">&#123;</div><div class="line">             return [self scheduledTimerWithTimeInterval:interval</div><div class="line">                                                  target:self</div><div class="line">                                                selector:@selector(eoc_blockInvoke:)</div><div class="line">                                                userInfo:[block copy]</div><div class="line">                                                 repeats:repeats];</div><div class="line"></div><div class="line">&#125;</div><div class="line">+ (void)eoc_blockInvoke:(NSTimer*)timer &#123;</div><div class="line">     void (^block)() = timer.userInfo;</div><div class="line">         if (block) &#123;</div><div class="line">             block();</div><div class="line">        &#125;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<hr>
<p><strong>EOF :</strong> 由于个人能力有限，难免有一些遗漏或者错误，请各位看官不吝赐教！谢谢！同时如果有任何问题也可以在下方留言，欢迎一起交流进步~最后感谢作者Matt Galloway以及译者！更多细节还是请翻阅图书，可以<a href="https://pan.baidu.com/s/1bpCj0i7" target="_blank" rel="external">点击这里下载</a>PDF版，原版英文版PDF我也有存~本文已经同步到<a href="http://www.superma.me/2017/08/06/%E9%87%8D%E6%B8%A9%E3%80%8AEffectiveObjective-C2-0%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FiOS%E4%B8%8EOSX%E4%BB%A3%E7%A0%81%E7%9A%8452%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95%E3%80%8B/" target="_blank" rel="external">个人博客</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在重温这本OC经典之作《Effective Objective-C 2.0编写高质量iOS与OS X代码的52个有效方法》，这篇文章算是重温之后的产物吧
    
    </summary>
    
      <category term="Objective-C" scheme="http://superma.me/all-categories/Objective-C/"/>
    
    
      <category term="Effective-OC" scheme="http://superma.me/all-tags/Effective-OC/"/>
    
  </entry>
  
  <entry>
    <title>iOS理解Objective-C中消息转发机制附Demo</title>
    <link href="http://superma.me/2017/07/30/iOS%E7%90%86%E8%A7%A3Objective-C%E4%B8%AD%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91%E6%9C%BA%E5%88%B6%E9%99%84Demo/"/>
    <id>http://superma.me/2017/07/30/iOS理解Objective-C中消息转发机制附Demo/</id>
    <published>2017-07-30T07:35:00.000Z</published>
    <updated>2017-08-05T17:23:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在重温Effective Objective-C 2.0，这篇文章属于重温的产物吧，本文会通过demo来讲解OC中的消息转发机制</p>
<a id="more"></a>
<p><img src="http://upload-images.jianshu.io/upload_images/1457495-ade801c636fc86fc.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>Demo:<a href="https://github.com/maligh/ML-Objective-C-Demo/tree/master/MessageForwarding" target="_blank" rel="external">点我查看,觉得有帮助的话不要吝惜你的star</a><br>话不多说，iOS开发过程中我们经常会碰到这样的报错：<code>unrecognized selector sent to instance **</code>，原因是我们调用了一个不存在的方法。用OC消息机制来说就是：消息的接收者不过到对应的selector，这样就启动了消息转发机制，我们可以通过代码在消息转发的过程中告诉对象应该如何处理未知的消息，默认实现是抛出下面的异常</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1457495-960047111dbd1c57.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="unrecognized selector.png"><br>下面我们通过实例来看一下在抛出异常之前也就是消息转发过程中都经过了哪些步骤：</p>
<hr>
<p>第一步：对象在收到无法解读的消息后，首先会调用<code>+(BOOL)resolveInstanceMethod:(SEL)sel</code>或者<code>+ (BOOL)resolveClassMethod:(SEL)sel</code>, 询问是否有动态添加方法来进行处理，处理实例如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">//People.m</div><div class="line">void speak(id self, SEL _cmd)&#123;</div><div class="line">    NSLog(@&quot;Now I can speak.&quot;);</div><div class="line">&#125;</div><div class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel &#123;</div><div class="line">    </div><div class="line">    NSLog(@&quot;resolveInstanceMethod:  %@&quot;, NSStringFromSelector(sel));</div><div class="line">    if (sel == @selector(speak)) &#123;</div><div class="line">        class_addMethod([self class], sel, (IMP)speak, &quot;V@:&quot;);</div><div class="line">        return YES;</div><div class="line">    &#125;</div><div class="line">    return [super resolveInstanceMethod:sel];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当People 收到了未知 speak选择子的消息的时候，如果是实例方法会首选调用上文的<code>resolveInstanceMethod:</code>方法，方法内通过判断选择子然后通过<code>class_addMethod</code>方法动态添加了一个speak的实现方法来解决掉这条未知的消息，此时消息转发过程提前结束。<br>但是当People 收到fly 这条未知消息的时候，第一步返回的是No，也就是没有动态新增实现方法的时候就会调用第二步</p>
<hr>
<p>第二步：既然第一步已经问过了，没有新增方法，那就问问有没有别人能够帮忙处理一下啊，调用的是<code>- (id)forwardingTargetForSelector:(SEL)aSelector</code>这个方法<br>上文我们说到People接收到了一条选择子为<code>fly</code>的未知消息，我们可以看到控制台已经打印了<code>resolveInstanceMethod:  fly</code>，代表第一步已经问过了，那么第二步问一下是否有别的类能帮忙处理吗？代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (id)forwardingTargetForSelector:(SEL)aSelector &#123;</div><div class="line">    NSLog(@&quot;forwardingTargetForSelector:  %@&quot;, NSStringFromSelector(aSelector));</div><div class="line">    Bird *bird = [[Bird alloc] init];</div><div class="line">    if ([bird respondsToSelector: aSelector]) &#123;</div><div class="line">        return bird;</div><div class="line">    &#125;</div><div class="line">    return [super forwardingTargetForSelector: aSelector];</div><div class="line">&#125;</div><div class="line">// Bird.m</div><div class="line">- (void)fly &#123;</div><div class="line">    NSLog(@&quot;I am a bird, I can fly.&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过<code>- (id)forwardingTargetForSelector:(SEL)aSelector</code>的处理，bird能够处理这条消息，所以这条消息被bird成功处理，消息转发流程提前结束。控制台打印<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">forwardingTargetForSelector:  fly</div><div class="line">I am a bird, I can fly.</div></pre></td></tr></table></figure></p>
<p>但是如果<code>- (id)forwardingTargetForSelector:(SEL)aSelector</code>也找不到能够帮忙处理这条未知消息，那就会走到最后一步，这步也是代价最大的一步</p>
<hr>
<p>第三步：调用<code>- (void)forwardInvocation:(NSInvocation *)anInvocation</code>，在调用<code>forwardInvocation:</code>之前会调用<code>- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</code>方法来获取这个选择子的方法签名，然后在<code>-(void)forwardInvocation:(NSInvocation *)anInvocation</code>方法中你就可以通过<code>anInvocation</code>拿到相应信息做处理，实例代码如下</p>
<p>当People 收到一条 选择子为code 的消息的时候，前两步发现都没办法处理掉，走到第三步：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation &#123;</div><div class="line">    NSLog(@&quot;forwardInvocation: %@&quot;, NSStringFromSelector([anInvocation selector]));</div><div class="line">    if ([anInvocation selector] == @selector(code)) &#123;</div><div class="line">        Monkey *monkey = [[Monkey alloc] init];</div><div class="line">        [anInvocation invokeWithTarget:monkey];</div><div class="line">    &#125;   </div><div class="line">&#125;</div><div class="line"></div><div class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123;</div><div class="line">    NSLog(@&quot;method signature for selector: %@&quot;, NSStringFromSelector(aSelector));</div><div class="line">    if (aSelector == @selector(code)) &#123;</div><div class="line">        return [NSMethodSignature signatureWithObjCTypes:&quot;V@:@&quot;];</div><div class="line">    &#125;</div><div class="line">    return [super methodSignatureForSelector:aSelector];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这时控制台会打印<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">resolveInstanceMethod:  code</div><div class="line">forwardingTargetForSelector:  code</div><div class="line">method signature for selector: code</div><div class="line">forwardInvocation: code</div><div class="line">I am a coder.</div></pre></td></tr></table></figure></p>
<p>此时这个code消息已经被monkey实例处理掉<br>此时消息转发流程完整的结束了，完整的消息转发流程如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1457495-8ee6afef466e6177.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<hr>
<p>那么最后消息未能处理的时候，还会调用到<br><code>- (void)doesNotRecognizeSelector:(SEL)aSelector</code>这个方法，我们也可以在这个方法中做些文章，避免掉crash，但是只建议在线上环境的时候做处理，实际开发过程中还要把异常抛出来</p>
<p>EOF:OC中消息转发流程大概就是这样了，Demo<a href="https://github.com/maligh/ML-Objective-C-Demo/tree/master/MessageForwarding" target="_blank" rel="external">点这里，觉得有帮助的话不要吝惜你的star</a>，由于个人能力有限，文中难免有些错误，希望大家不吝赐教~<br>另外有一个问题想问大家，+ (BOOL)resolveClassMethod:(SEL)sel 在这个方法中怎么动态添加类方法？ 比如我发送了一条未知的 [People missMethod]消息，怎么添加 +(void)missMethod 的实现呢？</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在重温Effective Objective-C 2.0，这篇文章属于重温的产物吧，本文会通过demo来讲解OC中的消息转发机制&lt;/p&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="http://superma.me/all-categories/Objective-C/"/>
    
    
      <category term="消息转发" scheme="http://superma.me/all-tags/%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C编程规范以及建议</title>
    <link href="http://superma.me/2017/07/04/Objective-C%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83%E4%BB%A5%E5%8F%8A%E5%BB%BA%E8%AE%AE/"/>
    <id>http://superma.me/2017/07/04/Objective-C编程规范以及建议/</id>
    <published>2017-07-04T15:36:51.000Z</published>
    <updated>2017-07-04T16:49:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录一下Objective-C编程规范以及一些建议，可能后续会有些修改和补充，至于初衷是最近接手的项目中代码”有些”凌乱，所以整理了一篇，有一些来自网上，有一些是我平时的代码风格的吧~<br><a id="more"></a><br><img src="http://upload-images.jianshu.io/upload_images/1457495-ad0b17b8f89cc097.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Flag"></p>
<h2 id="方法声明和定义"><a href="#方法声明和定义" class="headerlink" title="方法声明和定义"></a>方法声明和定义</h2><p>-或者+和返回类型之间须使用一个空格，括号要同行并有一个空格</p>
<p>方法应该像这样：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)doSomethingWithString:(<span class="built_in">NSString</span> *)theString &#123;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果函数名字太长，可以用冒号对齐，像这样：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)doSomethingWith:(GTMFoo *)theFoo</div><div class="line">                   rect:(<span class="built_in">NSRect</span>)theRect</div><div class="line">               interval:(<span class="keyword">float</span>)theInterval &#123;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当第一个关键字比其它的短时,要保证下一行至少有4个空格的缩进，对齐关键字，像这样：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)<span class="keyword">short</span>:(GTMFoo *)theFoo</div><div class="line">    longKeyword:(<span class="built_in">NSRect</span>)theRect</div><div class="line">    evenLongerKeyword:(<span class="keyword">float</span>)theInterval &#123;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h2><p>调用时所有参数应该在同一行：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[myObject doFooWith:arg1 name:arg2 error:arg3];</div></pre></td></tr></table></figure>
<p>或者每行一个参数，以冒号对齐：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[myObject doFooWith:arg1</div><div class="line">               name:arg2</div><div class="line">              error:arg3];</div></pre></td></tr></table></figure>
<p>方法定义与方法声明一样，当关键字的长度不足以以冒号对齐时，下一行都要以四个空格进行缩进</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[myObj <span class="keyword">short</span>:arg1</div><div class="line">    longKeyword:arg2</div><div class="line">    evenLongerKeyword:arg3];</div></pre></td></tr></table></figure>
<p>不要使用下面的缩进风格：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">[myObject doFooWith:arg1 name:arg2  <span class="comment">// some lines with &gt;1 arg</span></div><div class="line">              error:arg3];</div><div class="line"></div><div class="line">[myObject doFooWith:arg1</div><div class="line">               name:arg2 error:arg3];</div><div class="line"></div><div class="line">[myObject doFooWith:arg1</div><div class="line">          name:arg2  <span class="comment">// aligning keywords instead of colons</span></div><div class="line">          error:arg3];</div></pre></td></tr></table></figure>
<hr>
<h2 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h2><p>对于易维护的代码而言，命名规则非常重要。Objective-C 的方法名往往十分长，但代码块读起来就像散文一样，不需要太多的代码注释</p>
<p>当编写纯粹的 Objective-C 代码时，我们基本遵守标准的 <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CodingGuidelines/CodingGuidelines.html" target="_blank" rel="external">Objective-C naming rules</a>,</p>
<h2 id="文件名"><a href="#文件名" class="headerlink" title="文件名"></a>文件名</h2><table>
<thead>
<tr>
<th>扩展名</th>
<th>文件分类</th>
</tr>
</thead>
<tbody>
<tr>
<td>.h</td>
<td>C/C++/Objective-C 的头文件</td>
</tr>
<tr>
<td>.m</td>
<td>Objective-C 实现文件</td>
</tr>
<tr>
<td>.mm</td>
<td>Ojbective-C++ 的实现文件</td>
</tr>
<tr>
<td>.cc</td>
<td>纯 C++ 的实现文件</td>
</tr>
<tr>
<td>.c</td>
<td>纯C 的实现文件</td>
</tr>
</tbody>
</table>
<h2 id="类名"><a href="#类名" class="headerlink" title="类名"></a>类名</h2><p>类名（以及类别、协议名）应首字母大写，并以驼峰格式分割单词</p>
<h2 id="Objective-C-方法名"><a href="#Objective-C-方法名" class="headerlink" title="Objective-C 方法名"></a>Objective-C 方法名</h2><p>方法名应该以小写字母开头，并混合驼峰格式。每个具名参数也应该以小写字母开头<br>方法名应尽量读起来就像句子，这表示你应该选择与方法名连在一起读起来通顺的参数名。（例如，convertPoint:fromRect: 或 replaceCharactersInRange:withString:）。详情参见 <a href="http://developer.apple.com/documentation/Cocoa/Conceptual/CodingGuidelines/Articles/NamingMethods.html" target="_blank" rel="external">Apple’s Guide to Naming Methods</a><br>第二个参数不要<code>and</code>：</p>
<ul>
<li>正确: <code>- (instancetype)initWithWidth:(float)width :(float)height;</code> </li>
<li>不好: <code>- (id)initWithWidth:(float)width andHeight:(float)height;</code> </li>
</ul>
<h2 id="变量名"><a href="#变量名" class="headerlink" title="变量名"></a>变量名</h2><p>应该使用驼峰命名法，变量名尽量能够代表其自身意思，尽量避免中英文混合命名，中英文混合命名是建议用’_’下划线分割中英文。<br><strong>尽量避免如下命名方式</strong></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSDictionary</span> *d0 = [ACGPCacheCenter readFileAtSubDir: HSHomePageSubDirForAD];</div><div class="line"><span class="built_in">NSDictionary</span> *d2 = [ACGPCacheCenter readFileAtSubDir: HSHomePageSubDirForZX];</div><div class="line"><span class="built_in">NSDictionary</span> *d3 = [ACGPCacheCenter readFileAtSubDir: HSHPSubDirForEntry];</div><div class="line"><span class="built_in">NSDictionary</span> *d4 = [ACGPCacheCenter readFileAtSubDir: HSHPSubDirForCopywriting];</div></pre></td></tr></table></figure>
<p>循环以及一些生命周期很短、很浅显易懂的变量可以放开要求，可以使用简单单字母等等变量名</p>
<h2 id="常量名"><a href="#常量名" class="headerlink" title="常量名"></a>常量名</h2><p>常量名（如宏定义、枚举、静态局部变量等）应该以小写字母 k 开头，使用驼峰格式分隔单词，如：<code>kInvalidHandle，kWritePerm</code></p>
<hr>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>建议注释不要过多，尽量能够做到代码自解释。与其给类型及变量起一个晦涩难懂的名字，再为它写注释，不如直接起一个有意义的名字</p>
<p>关于注释有以下几点建议：</p>
<h3 id="h-文件注释"><a href="#h-文件注释" class="headerlink" title=".h 文件注释"></a>.h 文件注释</h3><p> <code>.h</code> 文件中 interface 前要加<code>VVDocumenter</code>注释，例如下面这个类，根据类名根本不知道哪个模块，做什么的。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">HSHPCopywritingCell</span> : <span class="title">HSBaseCollectionViewCell</span></span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>应改成</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> 首页模块-自选股cell</div><div class="line"> */</div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">HSHPCopywritingCell</span> : <span class="title">HSBaseCollectionViewCell</span></span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>之后在业务代码中遇到这个类，按住<code>alt</code>键鼠标点击类名就可以查看到类的<code>Description</code>如下：<br><img src="http://opmu2mji9.bkt.clouddn.com/123.png" alt=""></p>
<h3 id="属性以及成员变量注释"><a href="#属性以及成员变量注释" class="headerlink" title="属性以及成员变量注释"></a>属性以及成员变量注释</h3><p>属性、成员变量、枚举类型的注释建议用 <code>///&lt;</code>进行注释</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) HSMarketIndexModel *USmodel;      <span class="comment">///&lt; 美股指数model</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) HSMarketIndexModel *HKmodel;      <span class="comment">///&lt; 港股指数model</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) HSMarketIndexView *indexView;     <span class="comment">///&lt; 指数view</span></div></pre></td></tr></table></figure>
<p>同样按住<code>alt</code>键鼠标点击类名也可以查看到类的<code>Description</code>，用<code>/** 美股指数 */</code> 这种注释方式也可以看到Description，不过属性太多可能会不太美观</p>
<h3 id="代码块注释"><a href="#代码块注释" class="headerlink" title="代码块注释"></a>代码块注释</h3><p>善用<code>#pragma mark</code>把代码进行分类，<code>#pragma mark</code>没有下划线，<code>#pragma mark -</code>有下划线分割</p>
<p>建议用如下类似代码块组织代码：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#pragma mark - ================ LifeCycle =================</span></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">self</span> configUI];</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>) viewWillAppear:(<span class="built_in">BOOL</span>)animated &#123;</div><div class="line">&#125;...</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)configUI &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">#pragma mark - ================ Public Methods =================</span></div><div class="line"></div><div class="line"><span class="meta">#pragma mark ==== 核心公开方法注释</span></div><div class="line">- (<span class="keyword">void</span>)somePublicMethod &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">#pragma mark ==== 核心公开方法注释2</span></div><div class="line">- (<span class="keyword">void</span>)somePublicMethod2 &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">#pragma mark - ================ Private Methods =================</span></div><div class="line"></div><div class="line"><span class="meta">#pragma mark ==== 核心私有方法注释</span></div><div class="line">- (<span class="keyword">void</span>)somePrivateMethod &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">#pragma mark - ================ UITableView Delegate =================</span></div><div class="line"></div><div class="line">- (<span class="built_in">NSInteger</span>)numberOfSectionsInTableView:(<span class="built_in">UITableView</span> *)tableView &#123; </div><div class="line">&#125;...</div><div class="line"></div><div class="line"><span class="meta">#pragma mark - ================ Actions =================</span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)someButtonClicked &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">#pragma mark - ================ Getter and Setter =================</span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)setModelArray:(<span class="built_in">NSMutableArray</span> *)modelArray &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>注意:</strong>代码块的顺序应该是由重要到不重要，Getter之类的不重要代码块要放在最后，确保别人打开你的类先映入眼帘的是<code>有用的代码</code></p>
<hr>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="保持公共API简单"><a href="#保持公共API简单" class="headerlink" title="保持公共API简单"></a>保持公共API简单</h3><p>如果一个函数压根没必要公开，就不要这么做，属性也是一样，同时对方法进行合理的VVDocumenter注释，公开属性以及常量、枚举尽可能的用<code>///&lt;</code>注释，除非特别特别简单的可以省略</p>
<h3 id="关于警告"><a href="#关于警告" class="headerlink" title="关于警告"></a>关于警告</h3><p>代码中遇到警告信息应该尽量解决掉，有一些可能是类型转换警告，有一些是无用的变量，代码永远不会被执行，已废弃的方法等等，有一点<code>代码洁癖</code>、对自己的代码要求严格是一件好事</p>
<h3 id="关于废弃的代码"><a href="#关于废弃的代码" class="headerlink" title="关于废弃的代码"></a>关于废弃的代码</h3><p>项目中遇到废弃的代码、没有用到的类（头文件）、注释掉的代码，除非一定要保留的都要尽量删掉，保留的写好注释，建议用TODO注释，保留的原因以及相关责任人，以便其他人接手不至于懵逼~</p>
<hr>
<h2 id="一些建议"><a href="#一些建议" class="headerlink" title="一些建议"></a>一些建议</h2><h3 id="定义常量时：多用类型常量，少用-define预处理指令"><a href="#定义常量时：多用类型常量，少用-define预处理指令" class="headerlink" title="定义常量时：多用类型常量，少用#define预处理指令"></a>定义常量时：多用类型常量，少用#define预处理指令</h3><p>宏定义没有类型，有被重复定义风险，影响项目编译速度。<br>建议用</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kConst = <span class="string">@"Hello"</span>；</div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">CGFloat</span> kWidth = <span class="number">10.0</span>;</div></pre></td></tr></table></figure>
<p>代替：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#define kConst @<span class="meta-string">"Hello"</span></span></div><div class="line"><span class="meta">#define kWidth 10.0</span></div></pre></td></tr></table></figure>
<p>当定义对外公开的常量的时候，我们一般使用如下定义</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Test.h</span></div><div class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kClassNameconst;</div><div class="line"><span class="comment">//Test.m</span></div><div class="line"><span class="built_in">NSString</span> * <span class="keyword">const</span> kClassNameconst = <span class="string">@"hello"</span>;</div></pre></td></tr></table></figure>
<h3 id="关于枚举"><a href="#关于枚举" class="headerlink" title="关于枚举"></a>关于枚举</h3><p>推荐使用NS_ENUM和NS_OPTIONS定义 </p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>,TestEnum) &#123;</div><div class="line">    MY_INT_CONST = <span class="number">12345</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_OPTIONS</span>(<span class="built_in">NSInteger</span>, SelectType) &#123;</div><div class="line">    SelectA    = <span class="number">0</span>,</div><div class="line">    SelectB    = <span class="number">1</span> &lt;&lt; <span class="number">0</span>,</div><div class="line">    SelectC    = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,</div><div class="line">    SelectD    = <span class="number">1</span> &lt;&lt; <span class="number">2</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在枚举类型的switch语句中不要实现default分支，有一个好处是，当我们给枚举增加成员时，编译器就会提示开发者：<code>switch语句并未处理所有的枚举</code></p>
<h3 id="尽量使用简洁字面量语法"><a href="#尽量使用简洁字面量语法" class="headerlink" title="尽量使用简洁字面量语法"></a>尽量使用简洁字面量语法</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSArray</span> *animals = @[<span class="string">@"dog"</span>, <span class="string">@"pig"</span>, <span class="string">@"you"</span>];</div><div class="line">Dictionary *dict = @&#123;<span class="string">@"animal"</span>:<span class="string">@"tiger"</span>, <span class="string">@"phone"</span>:<span class="string">@"iPhone 6"</span>&#125;;</div><div class="line"></div><div class="line"><span class="built_in">NSString</span> *dog = animals[<span class="number">0</span>];</div><div class="line"><span class="built_in">NSString</span> *iphone = dict[<span class="string">@"phone"</span>];</div></pre></td></tr></table></figure>
<h3 id="属性的strong、copy"><a href="#属性的strong、copy" class="headerlink" title="属性的strong、copy"></a>属性的strong、copy</h3><p>定义可变类型时不要用copy修饰，会留下崩溃隐患</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSMutableArray</span> *mutableArrayOfCopy;   <span class="comment">///&lt; 插入数据时会崩溃</span></div></pre></td></tr></table></figure>
<p>一般NSString 以及NSArray等等不可变类型建议用<code>copy</code>修饰，用<code>strong</code>修饰也没错，不过要确定情景是否真的需要<code>strong</code></p>
<h2 id="结尾："><a href="#结尾：" class="headerlink" title="结尾："></a>结尾：</h2><p>本文对Objective-C编码粗略规范以及一些浅显建议，欢迎大家一起补充完善，共同交流进步，维护增强项目代码的易读性，易扩展性，健壮性等等~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文记录一下Objective-C编程规范以及一些建议，可能后续会有些修改和补充，至于初衷是最近接手的项目中代码”有些”凌乱，所以整理了一篇，有一些来自网上，有一些是我平时的代码风格的吧~&lt;br&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="http://superma.me/all-categories/Objective-C/"/>
    
    
      <category term="编码规范" scheme="http://superma.me/all-tags/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>iOS常量(const)、enum、宏(#define)的使用场景及区别</title>
    <link href="http://superma.me/2016/04/30/post/"/>
    <id>http://superma.me/2016/04/30/post/</id>
    <published>2016-04-29T18:37:54.000Z</published>
    <updated>2017-07-04T15:44:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>前言：本文主要梳理iOS中如何使用常量、enum、宏，以及各自的使用场景。<br><a id="more"></a><br><img src="http://upload-images.jianshu.io/upload_images/1457495-df0b95375604d34b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h2 id="重要的事情首先说："><a href="#重要的事情首先说：" class="headerlink" title="重要的事情首先说："></a>重要的事情首先说：</h2><p>在iOS开发中请尽量多使用const、enum来代替宏定义(#define)；随着项目工程的逐渐增大，过多的宏定义还会影响项目的编译时间</p>
<ul>
<li>宏定义大家应该都不陌生，使用起来非常简单，首先我们先来看一下宏定义跟const的区别：<br>1.宏在编译开始之前就会被替换，而const只是变量进行修饰;<br>2.宏可以定义一些函数方法，const不能<br>3.宏编译时只替换不做检查不报错，也就是说有重复定义问题。而const会编译检查，会报错</li>
</ul>
<hr>
<h2 id="那到底什么时候使用宏，什么时候该使用const？"><a href="#那到底什么时候使用宏，什么时候该使用const？" class="headerlink" title="那到底什么时候使用宏，什么时候该使用const？"></a>那到底什么时候使用宏，什么时候该使用const？</h2><!-- more -->
<ul>
<li>定义<code>不对外公开的常量</code>的时候，我们应该尽量先考虑使用 static 方式声名const来替代使用宏定义。const不能满足的情况再考虑使用宏定义。比如用以下定义：<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kConst = <span class="string">@"Hello"</span>；</div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">CGFloat</span> kWidth = <span class="number">10.0</span>;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>代替：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#define DEFINE @<span class="meta-string">"Hello"</span></span></div><div class="line"><span class="meta">#define WIDTH 10.0</span></div></pre></td></tr></table></figure></p>
<ul>
<li><p>当定义<code>对外公开的常量</code>的时候，我们一般使用如下定义：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Test.h</span></div><div class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> <span class="built_in">CLASSNAMEconst</span>;</div><div class="line"><span class="comment">//Test.m</span></div><div class="line"><span class="built_in">NSString</span> * <span class="keyword">const</span> <span class="built_in">CLASSNAMEconst</span> = <span class="string">@"hello"</span>;</div></pre></td></tr></table></figure>
<ul>
<li>对于整型类型，代替宏定义直接定义整型常量比较好的办法是使用enum，使用enum时推荐使用NS_ENUM和NS_OPTIONS宏。比如用以下定义：<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>,TestEnum) &#123;</div><div class="line">        MY_INT_CONST = <span class="number">12345</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p>代替：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#define MY_INT_CONST 12345</span></div></pre></td></tr></table></figure></p>
<p>NS_OPTIONS定义方式如下：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_OPTIONS</span>(<span class="built_in">NSInteger</span>, SelectType) &#123;</div><div class="line">        SelectA    = <span class="number">0</span>,</div><div class="line">        SelectB    = <span class="number">1</span> &lt;&lt; <span class="number">0</span>,</div><div class="line">        SelectC    = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,</div><div class="line">        SelectD    = <span class="number">1</span> &lt;&lt; <span class="number">2</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<!--readmore-->
<hr>
<h2 id="下面顺便说一下const-的一些使用方式，主要说明这几种写法的区别："><a href="#下面顺便说一下const-的一些使用方式，主要说明这几种写法的区别：" class="headerlink" title="下面顺便说一下const 的一些使用方式，主要说明这几种写法的区别："></a>下面顺便说一下const 的一些使用方式，主要说明这几种写法的区别：</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="built_in">NSString</span> *constString1 = <span class="string">@"I am a const NSString * string"</span>;</div><div class="line"><span class="built_in">NSString</span> <span class="keyword">const</span> *constString2 = <span class="string">@"I am a NSString const * string"</span>;</div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">NSString</span> *staticConstString1 = <span class="string">@"I am a static const NSString * string"</span>;</div><div class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> <span class="keyword">const</span> *staticConstString2 = <span class="string">@"I am a static NSString const * string"</span>;</div><div class="line"><span class="built_in">NSString</span> * <span class="keyword">const</span> stringConst = <span class="string">@"I am a NSString * const string"</span>;</div></pre></td></tr></table></figure>
<hr>
<p>全局变量：<br> <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//全局变量，constString1地址不能修改，constString1值能修改</span></div><div class="line"><span class="keyword">const</span> <span class="built_in">NSString</span> *constString1 = <span class="string">@"I am a const NSString * string"</span>;</div><div class="line"><span class="comment">//意义同上，无区别</span></div><div class="line"><span class="built_in">NSString</span> <span class="keyword">const</span> *constString2 = <span class="string">@"I am a NSString const * string"</span>;</div><div class="line"><span class="comment">// stringConst 地址能修改，stringConst值不能修改</span></div><div class="line"><span class="built_in">NSString</span> * <span class="keyword">const</span> stringConst = <span class="string">@"I am a NSString * const string"</span>;</div></pre></td></tr></table></figure></p>
<p>constString1 跟constString2 无区别.<br>＊左边代表指针本身的类型信息，const表示这个指针指向的这个地址是不可变的<br>＊右边代表指针指向变量的可变性，即指针存储的地址指向的内存单元所存储的变量的可变性</p>
<hr>
<p>局部常量：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//作用域只在本文件中</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">NSString</span> *kstaticConstString1 = <span class="string">@"I am a static const NSString * string"</span>;</div><div class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> <span class="keyword">const</span> *kstaticConstString2 = <span class="string">@"I am a static NSString const * string"</span>;</div><div class="line"><span class="comment">//---------------------------</span></div></pre></td></tr></table></figure></p>
<hr>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>不要用宏定义定义常量，能用const,enum替换的以后就少用宏定义吧。有任何问题或者指点请直接留言，欢迎拍砖~最后感谢你的时间~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前言：本文主要梳理iOS中如何使用常量、enum、宏，以及各自的使用场景。&lt;br&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="http://superma.me/all-categories/Objective-C/"/>
    
    
      <category term="宏" scheme="http://superma.me/all-tags/%E5%AE%8F/"/>
    
      <category term="常量" scheme="http://superma.me/all-tags/%E5%B8%B8%E9%87%8F/"/>
    
  </entry>
  
</feed>
