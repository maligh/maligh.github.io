<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>记录学习中的点滴,努力打怪升级-MaLi</title>
  <subtitle>记录学习中的点滴</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://superma.me/"/>
  <updated>2017-09-04T17:10:17.000Z</updated>
  <id>http://superma.me/</id>
  
  <author>
    <name>Mali</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS设计模式四部曲二:结构型模式内附Demo</title>
    <link href="http://superma.me/2017/09/05/iOS%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%9B%9B%E9%83%A8%E6%9B%B2%E4%BA%8C-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F%E5%86%85%E9%99%84Demo/"/>
    <id>http://superma.me/2017/09/05/iOS设计模式四部曲二-结构型模式内附Demo/</id>
    <published>2017-09-04T17:03:39.000Z</published>
    <updated>2017-09-04T17:10:17.000Z</updated>
    
    <content type="html"><![CDATA[<p> 本篇是四部曲的第二篇，第一篇请点这里<a href="http://www.jianshu.com/p/55f0e3b30e9c" target="_blank" rel="external">iOS设计模式四部曲(一):创建型模式 内附Demo</a>，关于设计模式强烈推荐图书《Head First设计模式》以及。由于个人能力有限，文中难免有一些遗漏或者错误，请各位看官不吝赐教！谢谢！本文所有Demo可以在我的Git上获取，<a href="https://github.com/maligh/DesignPatterns" target="_blank" rel="external">请点击这里</a></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1457495-9bef37686fbfa917.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="第二篇来了"><br><img src="http://upload-images.jianshu.io/upload_images/1457495-b27a7821529beb5d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="设计模式.png"></p>
<p>废话不多说，上图是整个设计模式的目录，这篇文章是其中的第二部分：结构型模式。结构型模式包括：<code>适配器模式（Adapter）</code>，<code>桥接模式（Bridge）</code>，<code>装饰器模式（Decorator）</code>，<code>组合模式（Composite）</code>，<code>外观模式（Facade）</code>，<code>享元模式（Flyweight）</code>，<code>代理模式（Proxy）</code>。下面我们就开始吧~</p>
<hr>
<h2 id="适配器模式（Adapter）："><a href="#适配器模式（Adapter）：" class="headerlink" title="适配器模式（Adapter）："></a>适配器模式（Adapter）：</h2><p><strong>1.定义:</strong> 适配器模式将一个类的接口变成调用者所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。(举一个现实中的实例：比如转接头)。<br><strong>2. 使用场景：</strong> 扩展应用或者组件时，而被集成进来的又不符合现在的接口，这个时候可以考虑使用适配器模式。<br><strong>3. 具体实现：</strong> 这里用举一个实际的例子，同声传译。举了一个虚拟的国际大会场景，主持人只会说英语，然后马云先生又听不懂英语（当然只是假设，事实是说的比中文都6），在乔布斯演讲之后，就到马云演讲，这个时候就需要一个翻译，去告诉马云可以开始你的表演啦😄，具体<a href="https://github.com/maligh/DesignPatterns/tree/master/MLDesignPatterns-OC/MLDesignPatterns-OC/Adapter" target="_blank" rel="external">Demo点击这里查看</a><br><strong>4.优点：</strong> 通过使用适配器让不兼容的接口变成了兼容，让调用者从实现类的接口解耦。在不修改原有代码的基础上增加新的适配器类，所以灵活性和扩展性比较好，哪天不想用了，就一起卸载掉。<br><strong>5.缺点：</strong> 只有集成具有类似功能的组件时，适配器模式才具有使用价值。具有相似功能具体指：API不一样，但是功能是相似的。<br><strong>6.注意事项:</strong> 适配器模式一般不是为了解决还处在于开发阶段的问题，一般都是解决正在服役项目的扩展问题。</p>
<hr>
<h2 id="桥接模式（Bridge）："><a href="#桥接模式（Bridge）：" class="headerlink" title="桥接模式（Bridge）："></a>桥接模式（Bridge）：</h2><p><strong>1.定义:</strong> 桥接模式就是将抽象部分和实现部分解耦，从而使得两者可以独立的变化。<br><strong>2. 使用场景：</strong> 重用性要求较高的不希望或不适用使用继承的场景。也就是说当继承N层，达到层级有点爆炸的时候可以考虑使用此模式。<br><strong>3. 具体实现：</strong> 这里举了一个App不同模块可以切换不同主题的例子，桥接模式主打的是组合优于继承，<a href="https://github.com/maligh/DesignPatterns/tree/master/MLDesignPatterns-OC/MLDesignPatterns-OC/Bridge" target="_blank" rel="external">具体Demo点击查看</a>，如果没有用桥接模式的话，可能就会出现<code>MyRedModule</code>，<code>MyBlueModule</code>这样的类<br><strong>4.优点：</strong> 此模式分离了应用的抽象部分与实现部分，有利于扩充。<br><strong>5.缺点：</strong> 桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围具有一定的局限性。<br><strong>6.注意事项:</strong> 并不是一涉及继承就要考虑使用桥接模式，不然还要继承做什么？桥接模式的目的就是要对变化进行封装，尽可能的把变化的因素封装到最细最小的单元中，避免风险扩散。所以当发现类的继承有N层的时候，才需要去考虑使用该模式。</p>
<hr>
<h2 id="装饰器模式（Decorator）："><a href="#装饰器模式（Decorator）：" class="headerlink" title="装饰器模式（Decorator）："></a>装饰器模式（Decorator）：</h2><p><strong>1.定义:</strong> 装饰模式能动态的给一个对象添加一些额外的职责。就增加功能来说，装饰模式会比通过继承生成子类更为灵活。<br><strong>2. 使用场景：</strong> 需要动态地给一个对象增加功能，这些功能也可以动态地被撤销。<br><strong>3. 具体实现：</strong> Objective-C中的Category 就是装饰器模式的一种应用。这里举了一个鸡肉堡的例子，<a href="https://github.com/maligh/DesignPatterns/tree/master/MLDesignPatterns-OC/MLDesignPatterns-OC/Decorator" target="_blank" rel="external">具体Demo点击查看</a><br><strong>4.优点：</strong> 装饰器模式中定义的行为，能够在不创建大量子类的情况下，组合起来实现复杂的效果，比继承更加灵活。<br><strong>5.缺点：</strong> 装饰器模式会导致设计中出现许多的小对象，会让系统变得更加复杂，比如说出错调试时寻找错误可能需要逐级排查。</p>
<hr>
<h2 id="组合模式（Composite）："><a href="#组合模式（Composite）：" class="headerlink" title="组合模式（Composite）："></a>组合模式（Composite）：</h2><p><strong>1.定义:</strong> 组合模式将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。<br><strong>2. 使用场景：</strong> 维护和展示部分-整体关系的场景，在具有整体和部分的层次结构中，希望通过一种方式忽略整体与部分的差异，可以一致地对待它们的时候。<br><strong>3. 具体实现：</strong> 这里举一个文件系统的例子<br><img src="http://upload-images.jianshu.io/upload_images/1457495-8a193f7beaa6017c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>这里有这个目录下有<code>文件夹Composite</code>和<code>main实现文件</code>，<code>文件夹Composite</code>下有<code>实现文件</code>和<code>头文件</code>。<a href="https://github.com/maligh/DesignPatterns/tree/master/MLDesignPatterns-OC/MLDesignPatterns-OC/Composite" target="_blank" rel="external">Demo点击这里查看</a></p>
<p><strong>4.优点：</strong> 1.高层模块调用简单。2.节点自由增加，而不必更改原来代码。3.叶子对象可以被组合成更复杂的容器对象，而这个容器对象又可以被组合，这样不断递归下去，可以形成复杂的树形结构。<br><strong>5.缺点：</strong> 使设计变得更加抽象，对象的业务规则如果很复杂，则实现组合模式具有很大挑战性，而且不是所有的方法都与叶子对象子类都有关联。<br><strong>6.注意事项:</strong> 当使用这个属性结构的调用组件能够通过同一个类或者协议来使用书中包含的所有的对象时，才能证明正确的实现了此模式。</p>
<hr>
<h2 id="外观模式（Facade）："><a href="#外观模式（Facade）：" class="headerlink" title="外观模式（Facade）："></a>外观模式（Facade）：</h2><p><strong>1.定义:</strong> 外观模式要求一个子系统的外部与内部的通信必须通过一个统一的对象进行。外观模式提供一个高层次的接口，用来访问子系统中的一群接口。<br><strong>2. 使用场景：</strong> 当一个复杂子系统需要提供一个简单的调用接口时可以使用外观模式。<br><strong>3. 具体实现：</strong> 外观模式比较容易理解，这里举一个家电管家的例子，命令起床，命令睡觉。家电管家帮你做关灯，拉窗帘等等一系列操作。<a href="https://github.com/maligh/DesignPatterns/tree/master/MLDesignPatterns-OC/MLDesignPatterns-OC/Facade" target="_blank" rel="external">具体Demo请点击这里查看</a><br><strong>4.优点：</strong> 使用此模式可以将复杂的API代码隐藏到一个简单的接口中，减少调用者直接对复杂API的依赖和耦合。修改时也只需要修改简单的接口即可。<br><strong>5.缺点：</strong> 不太遵守开闭原则，一旦发现有一些操作的时候，或者在增加新的子系统的时候，可能需要修改外观类代码，可能会造成一些风险。</p>
<hr>
<h2 id="享元模式（Flyweight）："><a href="#享元模式（Flyweight）：" class="headerlink" title="享元模式（Flyweight）："></a>享元模式（Flyweight）：</h2><p><strong>1.定义:</strong> 享元模式就是运行共享技术有效地支持大量细粒度对象的复用<br><strong>2. 使用场景：</strong> 系统中存在大量的相似对象，由于这类对象的大量使用可能会造成系统内存资源浪费，而且这些对象的状态大部分可以外部化，这个时候可以考虑享元模式。在iOS中，我们用到的UITableView 重用机制就是享元模式的典型应用。<br><strong>3. 具体实现：</strong> 这里通过了一个画圆的Demo来演示一下享元模式，<a href="https://github.com/maligh/DesignPatterns/tree/master/MLDesignPatterns-OC/MLDesignPatterns-OC/Flyweight" target="_blank" rel="external">具体Demo请点击这里查看</a><br><strong>4.优点：</strong> 通过共享极大的减少了对象实例的个数，节省了内存开销。<br><strong>5.缺点：</strong> 1.提高了系统的复杂度，需要分离出外部状态和内部状态。 2.这些类必须有一个工厂对象加以控制。</p>
<hr>
<h2 id="代理模式（Proxy）："><a href="#代理模式（Proxy）：" class="headerlink" title="代理模式（Proxy）："></a>代理模式（Proxy）：</h2><p><strong>1.定义:</strong> 代理模式为其他对象提供一种代理以控制对这个对象的访问。<br><strong>2. 使用场景：</strong> 想在访问一个类时做一些控制。<br><strong>3. 具体实现：</strong> 这里举一个实际的例子，就是火车票代售点，<a href="https://github.com/maligh/DesignPatterns/tree/master/MLDesignPatterns-OC/MLDesignPatterns-OC/Proxy" target="_blank" rel="external">具体实现Demo请点击这里查看</a><br><strong>4.优点：</strong> 1、职责清晰。 2、高扩展性。<br><strong>5.缺点：</strong> 增加了系统的复杂度<br><strong>6.注意事项:</strong> 1、和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。 2、和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。</p>
<hr>
<p><strong>EOF:</strong>这篇文章通过<a href="https://github.com/maligh/DesignPatterns/tree/master/MLDesignPatterns-OC/MLDesignPatterns-OC/" target="_blank" rel="external">Demo</a>梳理了设计模式中的结构型模式，由于个人能力有限，难免有一些遗漏或者错误，<strong>还请各位看官不吝赐教！</strong> 最近工作有点忙，剩下的部分会尽量抽时间早点完成。本文已同步到<a href="">个人博客</a>，<strong>欢迎关注，欢迎点赞，欢迎star，欢迎一起交流，一起进步！</strong>🤓</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 本篇是四部曲的第二篇，第一篇请点这里&lt;a href=&quot;http://www.jianshu.com/p/55f0e3b30e9c&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;iOS设计模式四部曲(一):创建型模式 内附Demo&lt;/a&gt;，关于设计模式强烈
    
    </summary>
    
      <category term="设计模式" scheme="http://superma.me/all-categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://superma.me/all-tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Objective-C" scheme="http://superma.me/all-tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>iOS设计模式四部曲一创建型模式内附Demo</title>
    <link href="http://superma.me/2017/08/22/iOS%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%9B%9B%E9%83%A8%E6%9B%B2%E4%B8%80%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%E5%86%85%E9%99%84Demo/"/>
    <id>http://superma.me/2017/08/22/iOS设计模式四部曲一创建型模式内附Demo/</id>
    <published>2017-08-21T17:18:45.000Z</published>
    <updated>2017-08-21T17:25:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>  最近刚重温完经典书籍<a href="http://www.jianshu.com/p/862b064e82e0" target="_blank" rel="external">《EffectiveObjective-C2.0编写高质量iOS与OSX代码的52个有效方法》</a>，接下来准备把设计模式扫扫盲<a id="more"></a>，强烈推荐图书《Head First设计模式》，如果看完了有空可以翻翻《大话设计模式》或者《设计模式之禅》，这几篇就是阅读学习设计模式的产物吧。因设计模式大致可分三种类型以及MVX架构系列，所以总共分了4篇来讲解：<code>创建型模式篇</code>，<code>结构性模式篇</code>，<code>行为型模式篇</code>，<code>架构型模式篇</code>，这是第一篇，由于个人能力有限，难免有一些遗漏或者错误，请各位看官不吝赐教！谢谢！本文所有Demo可以在我的Git上获取，<a href="https://github.com/maligh/DesignPatterns" target="_blank" rel="external">请点击这里</a></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1457495-b27a7821529beb5d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="设计模式.png"></p>
<p>闲言碎语不多讲，上图是本系列的一个总体大纲。这篇文章是第一部：创建型模式。不过在开讲之前首先说一下设计模式的六大原则：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1457495-4cac842b1e171838.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>关于这六大原则的解释，具体可以看我之前整理的一篇文章，<a href="http://www.jianshu.com/p/807bc228dbc2" target="_blank" rel="external">请点击这里前往</a><br>创建型模式包括：<code>原型模式</code>，<code>单例模式</code>，<code>工厂方法模式</code>，<code>抽象工厂模式</code>，<code>建造者模式</code>，下面我们就通过<a href="https://github.com/maligh/DesignPatterns" target="_blank" rel="external">Demo</a>来一个一个讲解。</p>
<hr>
<h2 id="原型模式（Prototype）："><a href="#原型模式（Prototype）：" class="headerlink" title="原型模式（Prototype）："></a>原型模式（Prototype）：</h2><p><strong>1. 定义：</strong>原型模式是通过克隆已有的对象来创建新的对象，已有的对象称为原型。通俗来讲，原型模式就是允许你创建现有对象的副本并根据需要进行修改，而不是从头开始创建对象并进行设置。<br><strong>2. 使用场景：</strong>通过初始化产生一个对象需要非常繁琐的准备步骤，也就是新生成一个对象的代价比较大，则可以考虑使用原型模式。<br><strong>3. 具体实现：</strong>原型模式实现起来比较简单，iOS实现这个模式用的就是<code>copy</code>方法，如果是类使用<code>copy</code>，那这个类就要实现。<code>NSCopying</code>协议中的<code>copyWithZone</code>方法，告诉程序如何复制该对象。（当然也可以自己定义协议和自定义copy方法来克隆，但是不建议这样做)。具体代码可以看<a href="https://github.com/maligh/DesignPatterns/tree/master/MLDesignPatterns-OC/MLDesignPatterns-OC/Prototype" target="_blank" rel="external">Demo</a>。另外在<code>Foudation</code>框架中你也会找到大量实现了<code>NSCopying</code>或者<code>NSMutableCopying</code>的类。<br><strong>4.优点：</strong> 在某些场景可以避免内存开销大的创建初始化动作。<br><strong>5.缺点：</strong> 基本没有缺点可言。<br><strong>6.注意事项:</strong> 涉及到<code>copy</code>，注意下深复制和浅复制就好。</p>
<hr>
<h2 id="单例模式（Singleton）："><a href="#单例模式（Singleton）：" class="headerlink" title="单例模式（Singleton）："></a>单例模式（Singleton）：</h2><p><strong>1.定义:</strong> 单例模式能够确保某个类在应用中只存在一个实例，创建之后会向整个系统共用这个实例。<br><strong>2. 使用场景：</strong> 需要用来保存全局的状态，并且不和任何作用域绑定的时候可以考虑单例。<br><strong>3. 具体实现：</strong><br>最简单最常见的一种实现方式:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">+ (instancetype)sharedInstance &#123;</div><div class="line">    static id shareInstance;</div><div class="line">    static dispatch_once_t onceToken;</div><div class="line">    dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">        shareInstance = [[self alloc] init];</div><div class="line">    &#125;);</div><div class="line">    return shareInstance;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>4.优点：</strong>在某些场景节省了一些内存开销，尤其是对一个需要频繁创建销毁的对象。<br><strong>5.缺点：</strong>单例对象一旦建立，对象指针是保存在静态区的，单例对象在堆中分配的内存空间，会在应用程序终止后才会被释放。虽然也可以做到提前释放，但一般很少这样去做。另外单例类无法继承，扩展很困难。<br><strong>6.注意事项:</strong> 单例模式比较常用，也可能是很多初级工程师唯一会使用的设计模式。这里还是要尽量避免滥用单例，大家可以查看<a href="https://www.objccn.io/issue-13-2/" target="_blank" rel="external">这篇文章</a> 另外还要防止一下对单例对象的<code>copy</code>操作。</p>
<hr>
<h2 id="工厂方法模式（FactoryMethod）："><a href="#工厂方法模式（FactoryMethod）：" class="headerlink" title="工厂方法模式（FactoryMethod）："></a>工厂方法模式（FactoryMethod）：</h2><p><strong>1.定义:</strong> 定义一个用于创建对象的接口，让子类决定实例化哪一个类。<br><strong>2. 使用场景：</strong> 当存在多个类共同实现一个协议或者共同继承一个基类的时候，需要创建不同的对象，这个时候就可以考虑是否有必要使用工厂类进行管理。<br><strong>3. 具体实现：</strong>  这里引用《设计模式之禅》一书中女娲造人的示例，<a href="https://github.com/maligh/DesignPatterns/tree/master/MLDesignPatterns-OC/MLDesignPatterns-OC/FactoryMethod" target="_blank" rel="external">具体实现请看demo</a>，另外还有工厂方法模式还可以缩小成简单工厂模式，形如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//CarFactory.m</div><div class="line">+ (Car *)createCarWithType:(NSIntger)passengersCount &#123;</div><div class="line">    if (passengersCount &lt; 2) &#123;</div><div class="line">        return [[SportCar alloc] init];</div><div class="line">    &#125; else if (passengersCount &lt; 4) &#123;</div><div class="line">        return [[NormalCar alloc] init];</div><div class="line">    &#125; else &#123;</div><div class="line">        return [[SUV alloc] init];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>但简单工厂模式的耦合和扩展方面存在一些问题，基本所有使用简单工厂模式的地方都可以用<code>依赖注入</code>来解决掉这个问题。<br><strong>4.优点：</strong> 1.在工厂方法中，用户只需要知道所要产品的具体工厂，不需要知道具体的创建过程，甚至不需要具体产品类。2.在系统增加新的产品时，我们只需要添加一个具体产品类和对应的实现工厂，无需对原工厂进行任何修改，很好地符合了“开闭原则”。<br><strong>5.缺点：</strong> 每次增加一个产品时，都需要增加一个具体类和对象实现工厂，代码量会增加，也增加了系统的复杂度。</p>
<hr>
<h2 id="抽象工厂模式（AbstractFactory）："><a href="#抽象工厂模式（AbstractFactory）：" class="headerlink" title="抽象工厂模式（AbstractFactory）："></a>抽象工厂模式（AbstractFactory）：</h2><p><strong>1.定义:</strong> 抽象工厂模式是工厂方式模式的升级版本，抽象工厂模式允许调用组件在不了解创建对象所需类的情况下，创建一组相关或者互相依赖的对象。<br><strong>2. 使用场景：</strong> 一个对象族有相同的约束时可以使用抽象工厂模式。<br><strong>3. 具体实现：</strong> 这里引用了一个生产门的工厂，木门需要搭配木门安装工，铁门需要搭配铁门安装工，<a href="https://github.com/maligh/DesignPatterns/tree/master/MLDesignPatterns-OC/MLDesignPatterns-OC/AbstractFactory" target="_blank" rel="external">具体实现请看demo</a><br><strong>4.优点：</strong> 良好的封装性：抽象工厂模式允许调用组件不必了解创建对象使用的类，也不必知道为什么选择这些类，因为我可以在不修改调用组件的情况下，对使用的类进行修改。<br><strong>5.缺点：</strong>  扩展产品族困难，需要更改接口及其下所有子类(什么是产品族：在抽象工厂模式中，产品族是指由同一个工厂生产的。例如苹果手机，苹果平板，苹果电脑)。</p>
<hr>
<h2 id="建造者模式（Builder）："><a href="#建造者模式（Builder）：" class="headerlink" title="建造者模式（Builder）："></a>建造者模式（Builder）：</h2><p><strong>1.定义:</strong> 将一个复杂的对象的构建与他的表示分离，使得同样的构建过程可以创建不同的表示。<br><strong>2. 使用场景：</strong> 当创建多种风格的对象时或者创建对象时涉及很多步骤，可以使用建造者模式。<br><strong>3. 具体实现：</strong> 这里举了一个手抓饼的例子，5元的不辣手抓饼需要添加（生菜 + 火腿肠 + 鸡蛋，味精 + 番茄酱），10元的变态辣手抓饼需要添加(生菜 + 热狗 + 肉松 + 里脊 + 芝士，辣椒 + 辣酱 + 麻酱 + 干辣椒 + 剁辣椒 + 老干妈 + 辣椒油)，<a href="https://github.com/maligh/DesignPatterns/tree/master/MLDesignPatterns-OC/MLDesignPatterns-OC/Builder" target="_blank" rel="external">具体实现请看demo</a><br><strong>4.优点：</strong> 1.将产品的创建过程与产品本身分离开来，可以使用相同的创建过程来得到不同的产品。2.每一个具体建造者都相对独立，因此可以很方便地替换具体建造者或增加新的具体建造者。<br><strong>5.缺点：</strong> 1.建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。2.如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。</p>
<hr>
<p><strong>EOF :</strong> 这篇文章通过<a href="https://github.com/maligh/DesignPatterns/tree/master/MLDesignPatterns-OC/MLDesignPatterns-OC/" target="_blank" rel="external">Demo</a>梳理了设计模式中的创建型模式，由于个人能力有限，难免有一些遗漏或者错误，还请各位看官不吝赐教！下周会给大家带来第二篇<code>结构性模式篇</code>，本文已同步到<a href="http://www.superma.me/2017/08/22/iOS%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%9B%9B%E9%83%A8%E6%9B%B2%E4%B8%80%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%E5%86%85%E9%99%84Demo/" target="_blank" rel="external">个人博客</a>，<strong>欢迎关注，欢迎点赞，欢迎star，欢迎一起交流，一起进步！</strong>🤓</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  最近刚重温完经典书籍&lt;a href=&quot;http://www.jianshu.com/p/862b064e82e0&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《EffectiveObjective-C2.0编写高质量iOS与OSX代码的52个有效方法》&lt;/a&gt;，接下来准备把设计模式扫扫盲
    
    </summary>
    
      <category term="设计模式" scheme="http://superma.me/all-categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://superma.me/all-tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Objective-C" scheme="http://superma.me/all-tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>重温《EffectiveObjective-C2.0编写高质量iOS与OSX代码的52个有效方法》</title>
    <link href="http://superma.me/2017/08/06/%E9%87%8D%E6%B8%A9%E3%80%8AEffectiveObjective-C2-0%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FiOS%E4%B8%8EOSX%E4%BB%A3%E7%A0%81%E7%9A%8452%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95%E3%80%8B/"/>
    <id>http://superma.me/2017/08/06/重温《EffectiveObjective-C2-0编写高质量iOS与OSX代码的52个有效方法》/</id>
    <published>2017-08-05T17:06:36.000Z</published>
    <updated>2017-08-09T15:50:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在重温这本OC经典之作《Effective Objective-C 2.0编写高质量iOS与OS X代码的52个有效方法》，这篇文章算是重温之后的产物吧<a id="more"></a>，读完这篇文章你将快速读完这本书，由于个人能力有限，难免有一些遗漏或者错误，请各位看官不吝赐教~谢谢~同时如果有任何问题也可以在下方留言，欢迎一起交流进步~另外由于篇幅原因，书中一些基础知识的介绍文中就省略掉了~</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1457495-debf9e0c37687e51.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="目录"><br>上面就是这本书的目录，可以<a href="https://pan.baidu.com/s/1bpCj0i7" target="_blank" rel="external">点击这里下载</a>PDF版，原版英文版PDF我也有存~</p>
<hr>
<h2 id="第一章：熟悉Objective-C"><a href="#第一章：熟悉Objective-C" class="headerlink" title="第一章：熟悉Objective-C"></a>第一章：熟悉Objective-C</h2><h3 id="第一条：了解Objective-C语言的起源"><a href="#第一条：了解Objective-C语言的起源" class="headerlink" title="第一条：了解Objective-C语言的起源"></a>第一条：了解Objective-C语言的起源</h3><ol>
<li><code>Objective-C</code>从Smalltalk语言是从<code>Smalltalk</code>语言演化而来，<br><code>Smalltalk</code>是消息语言的鼻祖。</li>
<li><code>Objective-C</code>是<code>C语言</code>的超集，在<code>C语言</code>基础上添加了面向对象等特性，可能一开始接触时你会觉得语法有点奇怪，那是因为<code>Objective-C</code>使用了动态绑定的<code>消息结构</code>，而<code>Java</code>，<code>C++</code>等等语言使用的是函数调用。</li>
<li><code>消息结构</code>与<code>函数调用</code>的关键区别在于：函数调用的语言，在编译阶段由<code>编译器</code>生成一些<code>虚方法表</code>，在运行时从这个表找到所要执行的方法去执行。而使用了动态绑定的<code>消息结构</code>在运行时接到一条消息，接下来要执行什么代码是运行期决定的，而不是编译器。</li>
</ol>
<h3 id="第二条：-在类的文件中尽量少引用其他头文件"><a href="#第二条：-在类的文件中尽量少引用其他头文件" class="headerlink" title="第二条： 在类的文件中尽量少引用其他头文件"></a>第二条： 在类的文件中尽量少引用其他头文件</h3><ol>
<li>如果需要引用一个类文件时，只是需要使用类名，不需要知道其中细节，可以用<code>@class xx.h</code>，这样做的好处会减少一定的编译时间。如果是用的<code>#import</code>全部导入的话，会出现<code>a.h</code> import了<code>b.h</code>,当<code>c.h</code> 又import <code>a.h</code>时，把<code>b.h</code>也都导入了，如果只是用到类名，真的比较浪费，也不够优雅</li>
<li>有时候无法使用<code>@class</code>向前声明，比如某个类要遵循一项协议，这个协议在另外一个类中声明的，可以将协议这部分单独放在一个头文件，或者放在分类当中，以降低引用成本。</li>
</ol>
<h3 id="第三条：多用字面量语法，少用与之等价的方法"><a href="#第三条：多用字面量语法，少用与之等价的方法" class="headerlink" title="第三条：多用字面量语法，少用与之等价的方法"></a>第三条：多用字面量语法，少用与之等价的方法</h3><p>1.多使用字面量语法来创建字符串，数组，字典等。<br><strong>传统创建数组方法:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">NSArray *languages = [NSArray arrayWithObjects:@&quot;PHP&quot;, @&quot;Objective-C&quot;, someObject, @&quot;Swift&quot;, @&quot;Python&quot;, nil];</div><div class="line">NSString *Swift = [languages objectAtIndex:2];</div><div class="line">NSDictionary *dict = [NSDictionary dictionaryWithObjectsAndKeys:@&quot;key&quot;, @&quot;value&quot;, nil];</div><div class="line">NSString *value = [languages objectForKey:@&quot;key&quot;];</div></pre></td></tr></table></figure></p>
<p><strong>字面量:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">NSArray *languages = @[@&quot;PHP&quot;, @&quot;Objective-C&quot;, someObject, @&quot;Swift&quot;, @&quot;Python&quot;];</div><div class="line">NSString *Swift = languages[2];</div><div class="line">NSDictionary *dict = @&#123;@&quot;key&quot; : @&quot;value&quot;&#125;;</div><div class="line">NSString *value = languages[@&quot;key&quot;];</div></pre></td></tr></table></figure></p>
<p>这样做的好处：使代码更简洁，易读，也会避免nil问题。比如languages数据中 someObject 如果为nil时，字面量语法就会抛出异常，而使用传统方法创建的languages数组值确是<code>@[@&quot;PHP&quot;, @&quot;Objective-C&quot;];</code>因为字面量语法其实是一种语法糖，效果是先创建了一个数组，然后再把括号中的对象都加到数组中来。<br>不过字面量语法有一个小缺点就是创建的数组，字符串等等对象都是不可变的，如果想要可变的对象需要自己多执行一步<code>mutableCopy</code>，例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSMutableArray *languages = [@[@&quot;PHP&quot;, @&quot;Objective-C&quot;, @&quot;Swift&quot;, @&quot;Python&quot;] mutableCopy];</div></pre></td></tr></table></figure></p>
<h3 id="第四条：多用类型常量，少用-define预处理指令"><a href="#第四条：多用类型常量，少用-define预处理指令" class="headerlink" title="第四条：多用类型常量，少用#define预处理指令"></a>第四条：多用类型常量，少用#define预处理指令</h3><p><a href="http://www.jianshu.com/p/064b5b82a3a2" target="_blank" rel="external">第4条第5条看这里</a></p>
<h3 id="第五条：多用枚举表示状态、选项、状态码"><a href="#第五条：多用枚举表示状态、选项、状态码" class="headerlink" title="第五条：多用枚举表示状态、选项、状态码"></a>第五条：多用枚举表示状态、选项、状态码</h3><p><a href="http://www.jianshu.com/p/064b5b82a3a2" target="_blank" rel="external">第4条第5条看这里</a></p>
<hr>
<h2 id="第二章：对象、消息、运行期"><a href="#第二章：对象、消息、运行期" class="headerlink" title="第二章：对象、消息、运行期"></a>第二章：对象、消息、运行期</h2><h3 id="第六条：理解“属性”这一概念"><a href="#第六条：理解“属性”这一概念" class="headerlink" title="第六条：理解“属性”这一概念"></a>第六条：理解“属性”这一概念</h3><p>这一条讲的是属性的基本概念，以及属性的各种修饰符，这些就不多啰嗦了，这里强调一下:</p>
<ol>
<li>定义对外开放的属性时候尽量做到暴露权限最小化，不希望被修改的属性要加上<code>readonly</code>。</li>
<li><code>atomic</code> 并不能保证多线程安全，例如一个线程连续多次读取某个属性的值，而同时还有别的线程在修改这个属性值得时候，也还是一样会读到不同的值。atomic 的原理只是在 setter and getter 方法中加了一个<code>@synchronized(self)</code>，所以iOS开发中属性都要声明为<code>nonatomic</code>,因为atomic严重影响了性能，但是在Mac OSX上开发却通常不存在这个性能问题</li>
<li>说一下下面的哪个属性声明有问题<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic, strong) NSArray *arrayOfStrong;</div><div class="line">@property (nonatomic, copy) NSArray *arrayOfCopy;</div><div class="line">@property (nonatomic, strong) NSMutableArray *mutableArrayOfStrong;</div><div class="line">@property (nonatomic, copy) NSMutableArray *mutableArrayOfCopy;</div></pre></td></tr></table></figure>
</li>
</ol>
<p><a href="https://github.com/maligh/ML-Objective-C-Demo/tree/master/Copy-Strong-Array-MutableArray" target="_blank" rel="external">具体运行示例点击查看</a><br>答案是正常应该这样声明<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic, copy) NSArray *arrayOfCopy;</div><div class="line">@property (nonatomic, strong) NSMutableArray *mutableArrayOfStrong;</div></pre></td></tr></table></figure></p>
<h3 id="第七条：在对象内部尽量直接访问实例变量"><a href="#第七条：在对象内部尽量直接访问实例变量" class="headerlink" title="第七条：在对象内部尽量直接访问实例变量"></a>第七条：在对象内部尽量直接访问实例变量</h3><ol>
<li>在类内读取属性的数据时，应该通过直接实例变量来读，这样不经过Objecit-C的方法派发，编译器编译后的代码结果是直接访问存实例变量的那块内存中的值，而不会生成走方法派发的代码，这样的速度会更快。</li>
<li>给属性写入数据时，应该通过属性的方式来写入，这样会调用setter 方法。但是在某种情况下初始化方法以及dealloc方法中，总是应该直接通过实例变量来读写数据，这样做是为了避免子类复写了setter方法造成的异常。</li>
<li>使用了懒加载的属性，应该一直保持用属性的方式来读取写入数据。</li>
</ol>
<h3 id="第八条：理解“对象等同性”这一概念"><a href="#第八条：理解“对象等同性”这一概念" class="headerlink" title="第八条：理解“对象等同性”这一概念"></a>第八条：理解“对象等同性”这一概念</h3><p>思考下面输出什么？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">NSString *aString = @&quot;iphone 8&quot;;</div><div class="line">NSString *bString = [NSString stringWithFormat:@&quot;iphone %i&quot;, 8];</div><div class="line">NSLog(@&quot;%d&quot;, [aString isEqual:bString]);</div><div class="line">NSLog(@&quot;%d&quot;, [aString isEqualToString:bString]);</div><div class="line">NSLog(@&quot;%d&quot;, aString == bString);</div></pre></td></tr></table></figure></p>
<p>答案是110<br><code>==</code>操作符只是比较了两个指针，而不是指针所指的对象</p>
<h3 id="第九条：以“类族模式”隐藏实现细节"><a href="#第九条：以“类族模式”隐藏实现细节" class="headerlink" title="第九条：以“类族模式”隐藏实现细节"></a>第九条：以“类族模式”隐藏实现细节</h3><p>为什么下面这段if 永远为false<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">id maybeAnArray = @[];</div><div class="line">if ([maybeAnArray class] == [NSArray class]) &#123;</div><div class="line">     //Code will never be executed</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>因为[maybeAnArray class] 的返回永远不会是NSArray，NSArray是一个类族，返回的值一直都是NSArray的实体子类。大部分collection类都是某个类族中的’抽象基类’<br>所以上面的if想要有机会执行的话要改成<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">id maybeAnArray = @[];</div><div class="line">    if ([maybeAnArray isKindOfClass [NSArray class]) &#123;</div><div class="line">         //Code probably be executed</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>这样判断的意思是，maybeAnArray这个对象是否是NSArray类族中的一员<br><strong>使用类族的好处：可以把实现细节隐藏再一套简单的公共接口后面</strong></p>
<h3 id="第十条：在既有类中使用关联对象存放自定义数据"><a href="#第十条：在既有类中使用关联对象存放自定义数据" class="headerlink" title="第十条：在既有类中使用关联对象存放自定义数据"></a>第十条：在既有类中使用关联对象存放自定义数据</h3><p>这条讲的是<code>objc_setAssociatedObject</code>和<code>objc_getAssociatedObject</code>,如何使用在这里就不多说了。值得强调的一点是，用关联对象可能会引入难于查找的bug，毕竟是在runtime阶段，所以可能要看情况谨慎选择</p>
<h3 id="第十一条：理解“objc-msgSend”的作用"><a href="#第十一条：理解“objc-msgSend”的作用" class="headerlink" title="第十一条：理解“objc_msgSend”的作用"></a>第十一条：理解“objc_msgSend”的作用</h3><p>之前在<code>了解Objective-C语言的起源</code>有提到过，Objective-C是用的<code>消息结构</code>。这条就是让你理解一下怎么传递的消息。</p>
<ol>
<li>在Objective-C中，如果向某个对象传递消息，那就会在运行时使用动态绑定（dynamic binding）机制来决定需要调用的方法。但是到了底层具体实现，却是普通的C语言函数实现的。这个实现的函数就是<code>objc_msgSend</code>,该函数定义如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void objc_msgSend(id self, SEL cmd, ...)</div></pre></td></tr></table></figure>
</li>
</ol>
<p>这是一个参数个数可变的函数，第一参数代表<code>接收者</code>，第二个参数代表<code>选择子</code>（OC函数名），后续的参数就是消息（OC函数调用）中的那些参数</p>
<ol>
<li>举例来说：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">id return = [git commit:parameter];</div></pre></td></tr></table></figure>
</li>
</ol>
<p>上面的Objective-C方法在运行时会转换成如下函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">id return = objc_msgSend(git, @selector(commit), parameter);</div></pre></td></tr></table></figure></p>
<p>objc_msgSend函数会在接收者所属的类中搜寻其<code>方法列表</code>，如果能找到这个跟选择子名称相同的方法，就跳转到其实现代码，往下执行。若是当前类没找到，那就沿着继承体系继续向上查找，等找到合适方法之后再跳转 ，如果最终还是找不到，那就进入<code>消息转发</code>的流程去进行处理了。</p>
<ol>
<li>说过了OC的函数调用实现，你会觉得消息转发要处理很多，尤其是在搜索上，幸运的是objc_msgSend在搜索这块是有做缓存的，每个OC的类都有一块这样的缓存，objc_msgSend会将匹配结果缓存在<code>快速映射表</code>(fast map)中，这样以来这个类一些频繁调用的方法会出现在fast map 中，不用再去一遍一遍的在<code>方法列表</code>中搜索了。</li>
<li>还有一个有趣的点，就是在底层处理发送消息的时候，有用到<code>尾调用优化</code>，大概原理就是在函数末尾调用某个不含返回值函数时，编译器会自动的不在栈空间上重新进行分配内存，而是直接释放所有调用函数内部的局部变量，然后直接进入被调用函数的地址。</li>
</ol>
<h3 id="第十二条：理解消息转发机制"><a href="#第十二条：理解消息转发机制" class="headerlink" title="第十二条：理解消息转发机制"></a>第十二条：理解消息转发机制</h3><p>关于这条这看看这篇文章：<a href="http://www.jianshu.com/p/f9bd98ad5b05" target="_blank" rel="external">iOS理解Objective-C中消息转发机制附Demo</a></p>
<h3 id="第十三条：用“方法调配技术”调试“黑盒方法”"><a href="#第十三条：用“方法调配技术”调试“黑盒方法”" class="headerlink" title="第十三条：用“方法调配技术”调试“黑盒方法”"></a>第十三条：用“方法调配技术”调试“黑盒方法”</h3><p>这条讲的主要内容就是 Method Swizzling，通过运行时的一些操作可以用另外一份实现来替换掉原有的方法实现，往往被应用在向原有实现中添加新功能，比如扩展UIViewController，在viewDidLoad里面增加打印信息等。具体例子<a href="https://github.com/maligh/ML-OC-Catagory/tree/master/UIViewController%2BHookForLog" target="_blank" rel="external">可以点击我查看</a></p>
<h3 id="第十四条：理解“类对象”的用意"><a href="#第十四条：理解“类对象”的用意" class="headerlink" title="第十四条：理解“类对象”的用意"></a>第十四条：理解“类对象”的用意</h3><p>Objective-C类是由Class类型来表示的，它实际上是一个指向objc_class结构体的指针。它的定义如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">typedef struct objc_class *Class;</div></pre></td></tr></table></figure></p>
<p>在<objc runtime.h="">中能看到他的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">struct objc_class &#123;</div><div class="line">    Class isa  OBJC_ISA_AVAILABILITY;    ///&lt; 指向metaClass(元类)</div><div class="line"></div><div class="line">#if !__OBJC2__</div><div class="line">        Class super_class                       OBJC2_UNAVAILABLE;  ///&lt; 父类</div><div class="line">        const char *name                        OBJC2_UNAVAILABLE;  ///&lt; 类名</div><div class="line">        long version                            OBJC2_UNAVAILABLE;  ///&lt; 类的版本信息，默认为0</div><div class="line">        long info                               OBJC2_UNAVAILABLE;  ///&lt; 类信息，供运行期使用的一些位标识</div><div class="line">        long instance_size                      OBJC2_UNAVAILABLE;  ///&lt; 该类的实例变量大小</div><div class="line">        struct objc_ivar_list *ivars            OBJC2_UNAVAILABLE;  ///&lt; 该类的成员变量链表</div><div class="line">        struct objc_method_list **methodLists   OBJC2_UNAVAILABLE;  ///&lt; 方法定义的链表</div><div class="line">        struct objc_cache *cache                OBJC2_UNAVAILABLE;  ///&lt; 方法缓存</div><div class="line">        struct objc_protocol_list *protocols    OBJC2_UNAVAILABLE;  ///&lt; 协议链表</div><div class="line">#endif</div><div class="line"></div><div class="line">&#125; OBJC2_UNAVAILABLE;</div></pre></td></tr></table></figure></objc></p>
<p>此结构体存放的是类的“元数据”（metadata)，例如类的实例实现了几个方法，具备多少实例变量等信息。<br>这里的isa指针指向的是另外一个类叫做元类（metaClass)。那什么是元类呢？元类是类对象的类。也可以换一种容易理解的说法：</p>
<ol>
<li>当你给对象发送消息时，runtime处理时是在这个对象的类的方法列表中寻找</li>
<li>当你给类发消息时，runtime处理时是在这个类的元类的方法列表中寻找</li>
</ol>
<p>我们来看一个很经典的图来加深理解：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1457495-462fff9ae695d220.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>可以总结为下：</p>
<ol>
<li>每一个<code>Class</code>都有一个<code>isa指针</code>指向一个唯一的<code>Meta Class</code></li>
<li>每一个<code>Meta Class</code>的<code>isa指针</code>都指向最上层的<code>Meta Class</code>，这个<code>Meta Class</code>是<code>NSObject的Meta Class</code>。(包括<code>NSObject的Meta Class</code>的<code>isa指针</code>也是指向的<code>NSObject的Meta Class</code>，也就是自己，这里形成了个闭环)</li>
<li>每一个<code>Meta Class</code>的<code>super class</code>指针指向它<code>原本Class</code>的 <code>Super Class的Meta Class</code> (这里最上层的<code>NSObject的Meta Class</code>的<code>super class</code>指针还是指向自己)</li>
<li>最上层的<code>NSObject Class的super class</code>指向 nil</li>
</ol>
<h2 id="第三章：接口与API设计"><a href="#第三章：接口与API设计" class="headerlink" title="第三章：接口与API设计"></a>第三章：接口与API设计</h2><h3 id="第十五条：用前缀避免命名空间冲突"><a href="#第十五条：用前缀避免命名空间冲突" class="headerlink" title="第十五条：用前缀避免命名空间冲突"></a>第十五条：用前缀避免命名空间冲突</h3><p>Objective-C没有类似其他语言那样的命名空间机制(namespace)，比如说PHP中的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">namespace Root\Sub\subnamespace;</div></pre></td></tr></table></figure></p>
<p>这就会导致当你不小心实现了两个相同名字的类，或者把两个相对独立的库导入项目时而他们又恰好有重名的类的时候该类所对应的符号和Meta Class符号定义了两次。所以很容易产生这种命名冲突，让程序的链接过程中出现出现重复的符号造成报错。<br>为了避免这种情况，我们要尽量在类名，以及分类和分类方法上增加前缀，还有一些宏定义等等根据自己项目来定吧</p>
<h3 id="第十六条：提供“全能初始化方法”"><a href="#第十六条：提供“全能初始化方法”" class="headerlink" title="第十六条：提供“全能初始化方法”"></a>第十六条：提供“全能初始化方法”</h3><p>如果创建类的实例的方式不止一种，那么这个类就会有多个初始化方法，这样做很好，不过还是要在其中选定一个方法作为全能初始化方法，剩下的其余的初始化方法都要调用它，这样做的好处是以后如果初始化的逻辑更改了只需更改一处即可，或者是交给子类覆写的时候也只覆写这一个方法即可~<br>举个例子来说:可以看一下NSDate的实现在NSDate.h中NSDate类中定义了一个全能初始化方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (instancetype)initWithTimeIntervalSinceReferenceDate:(NSTimeInterval)ti NS_DESIGNATED_INITIALIZER;</div></pre></td></tr></table></figure></p>
<p>其余的类似初始化方式定义在NSDate (NSDateCreation) 分类中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (instancetype)initWithTimeIntervalSinceNow:(NSTimeInterval)secs;</div><div class="line">- (instancetype)initWithTimeIntervalSince1970:(NSTimeInterval)secs;</div><div class="line">- (instancetype)initWithTimeInterval:(NSTimeInterval)secsToBeAdded sinceDate:(NSDate *)date;</div></pre></td></tr></table></figure></p>
<p>在NSDate文档中有一条：<code>If you want to subclass NSDate to obtain behavior different than that provided by the private or public subclasses, you must do these things:</code>然后其中要做的有一步就是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Override [initWithTimeIntervalSinceReferenceDate:</div><div class="line">](apple-reference-documentation://hcslylvSCo), one of the designated initializer methods`</div></pre></td></tr></table></figure></p>
<p><strong>这个是我们组织代码过程中应该学习的地方！</strong></p>
<h3 id="第十七条：实现description方法"><a href="#第十七条：实现description方法" class="headerlink" title="第十七条：实现description方法"></a>第十七条：实现description方法</h3><p>这条讲的是可以通过覆写description方法或者debugDescription方法来在NSLog打印时或者LLDB打印时输出更多的自定义信息。(数据和字典的可以通过覆写<code>descriptionWithLocale:</code>方法)<br>友情提示：不要在description中使用 <code>NSLog(&quot;%@&quot;,self);</code>，不然会掉进无底深渊啊<br>这里我有一个有趣的想法，不过还没完全实现，就是想通过覆写description能把任何一个对象的属性值名称，属性值都一一完整的记录下来，<a href="https://github.com/maligh/ML-Objective-C-Demo/tree/master/MLDescription" target="_blank" rel="external">可以点击查看</a></p>
<h3 id="第十八条：尽量使用不可变对象"><a href="#第十八条：尽量使用不可变对象" class="headerlink" title="第十八条：尽量使用不可变对象"></a>第十八条：尽量使用不可变对象</h3><p>这条主要讲尽量使用不可变的对象，也就是在对外属性声明的时候要尽量加上readonly修饰，默认是readwrite，这样一来，在外部就只能读取该数据，而不能修改它，使得这个类的实例所持有的数据更加安全。如果外部想要修改，可以提供方法来进行修改。<br>不要把可变的collection作为属性公开，而应提供相关方法，以此修改对象中的可变collection(这条个人感觉一般在常用、重要的类才有必要，毕竟也增加了不少代码量)<br>比如例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//Language.h</div><div class="line">@property (nonatomic, strong) NSSet *set;</div></pre></td></tr></table></figure></p>
<p>应该改为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">//Language.h</div><div class="line">@property (nonatomic, strong, readonly) NSSet *languages;</div><div class="line">- (void)addLanguage:(NSString *)language;</div><div class="line">- (void)removeLanguage:(NSString *)language;</div><div class="line">//**.m</div><div class="line">@implementation Language &#123;</div><div class="line">    NSMutableSet *mutableLanguages;</div><div class="line">&#125;</div><div class="line">- (NSSet *)languages &#123;</div><div class="line">    return [_mutableLanguages copy];</div><div class="line">&#125;</div><div class="line">- (void)addLanguage:(NSString *)language &#123;</div><div class="line">    [_mutableLanguages addObject:language];</div><div class="line">&#125;</div><div class="line">- (void)removeLanguage:(NSString *)language &#123;</div><div class="line">     [_mutableLanguages removeObject:language];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="第十九条：使用清晰而协调的命名方式"><a href="#第十九条：使用清晰而协调的命名方式" class="headerlink" title="第十九条：使用清晰而协调的命名方式"></a>第十九条：使用清晰而协调的命名方式</h3><p>这条不用太强调了，具体也可以参照一下我之前拟的<a href="http://www.jianshu.com/p/bbb0b57eb168" target="_blank" rel="external">Objective-C编程规范及建议</a>，后续可能会不断补充更新</p>
<h3 id="第二十条：为私有方法名加前缀"><a href="#第二十条：为私有方法名加前缀" class="headerlink" title="第二十条：为私有方法名加前缀"></a>第二十条：为私有方法名加前缀</h3><p>这条讲的是应该为类内的私有方法增加前缀，以便区分，这个感觉因人而异吧，感觉只要你不随便把私有方法暴露在.h文件都能接受，曾遇到过这样的同事，感觉其不太适合写程序吧。</p>
<h3 id="第二十一条：理解Objective-C错误模型"><a href="#第二十一条：理解Objective-C错误模型" class="headerlink" title="第二十一条：理解Objective-C错误模型"></a>第二十一条：理解Objective-C错误模型</h3><p>很多语言都有异常处理机制，Objective-C也不例外，Objective-C也有类似的@throw，不过在OC中使用@throw可能会导致内存泄漏，可能是它被设计的使用场景的问题。建议@throw只用来处理严重错误，也可以理解为致命错误(fatal error)，那么处理一般错误的时候（nonfatal error）时可以使用NSError。</p>
<h3 id="第二十二条：理解NSCopying协议"><a href="#第二十二条：理解NSCopying协议" class="headerlink" title="第二十二条：理解NSCopying协议"></a>第二十二条：理解NSCopying协议</h3><p>在OC开发中，使用对象时经常需要拷贝它，我们会通过<code>copy/mutbleCopy</code>来完成。如果想让自己的类支持拷贝，那必须要实现<code>NSCopying</code>协议，只需要实现一个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (id)copyWithZone:(NSZone*)zone</div></pre></td></tr></table></figure></p>
<p>当然如果要求返回对象是可变的类型就要用到<code>NSMutableCopying</code>协议，相应方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (id)mutableCopyWithZone:(NSZone *)zone</div></pre></td></tr></table></figure></p>
<p>在拷贝对象时，需要注意拷贝执行的是浅拷贝还是深拷贝。深拷贝在拷贝对象时，会将对象的底层数据也进行了拷贝。浅拷贝是创建了一个新的对象指向要拷贝的内容。一般情况应该尽量执行浅拷贝。</p>
<hr>
<h2 id="第四章：协议与分类"><a href="#第四章：协议与分类" class="headerlink" title="第四章：协议与分类"></a>第四章：协议与分类</h2><h3 id="第二十三条：通过委托与数据源协议进行对象间通信"><a href="#第二十三条：通过委托与数据源协议进行对象间通信" class="headerlink" title="第二十三条：通过委托与数据源协议进行对象间通信"></a>第二十三条：通过委托与数据源协议进行对象间通信</h3><p>这条讲的也比较基础，就是基本的delegate，protocal使用。<br>有一点稍微说一下：当某对象需要从另外一个对象中获取数据时，可以使用委托模式，这种用法经常被称为“数据源协议”（Data source Protocal）类似 <code>UITableview</code>的<code>UITableViewDataSource</code><br>另外在Swift中有一个很重要的思想就是面向协议编程。当然OC中也可以用协议来降低代码耦合性，必要的时候也可以替代继承，因为遵循同一个协议的类可以是任何，不必是同一个继承体系下。</p>
<h3 id="第二十四条：将类的实现代码分散到便于管理的数个分类之中"><a href="#第二十四条：将类的实现代码分散到便于管理的数个分类之中" class="headerlink" title="第二十四条：将类的实现代码分散到便于管理的数个分类之中"></a>第二十四条：将类的实现代码分散到便于管理的数个分类之中</h3><p>这条主要说的是通过分类机制，可以把类分成很多歌易于管理的小块。也是有一些前提的吧，可能是这个类业务比较复杂，需要瘦身，需要解耦等等。作者还推荐把私有方法统一放在Private分类中，以隐藏实现细节。这个个人觉得视情况而定吧。</p>
<h3 id="第二十五条：总是为第三方类的分类名称加前缀"><a href="#第二十五条：总是为第三方类的分类名称加前缀" class="headerlink" title="第二十五条：总是为第三方类的分类名称加前缀"></a>第二十五条：总是为第三方类的分类名称加前缀</h3><p>向第三方类的分类名称加上你专用的前缀，这点不必多说，😜</p>
<h3 id="第二十六条：勿在分类中声明属性"><a href="#第二十六条：勿在分类中声明属性" class="headerlink" title="第二十六条：勿在分类中声明属性"></a>第二十六条：勿在分类中声明属性</h3><p>不要在分类中声明属性，除了“class-continuation”分类中。那什么是“class-continuation”分类呢，其实就是我们经常在.m文件中用到的，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//Swift.m </div><div class="line">@interface Swift () </div><div class="line">//这个就是“class-continuation”分类</div><div class="line">@end</div><div class="line">@implementation Swift</div><div class="line">@end</div></pre></td></tr></table></figure></p>
<h3 id="第二十七条：使用“class-continuation”分类隐藏实现细节"><a href="#第二十七条：使用“class-continuation”分类隐藏实现细节" class="headerlink" title="第二十七条：使用“class-continuation”分类隐藏实现细节"></a>第二十七条：使用“class-continuation”分类隐藏实现细节</h3><p>这条跟之前的也有点重复，最终目的还是要尽量在公共接口中向外暴露的内容最小化，隐藏实现细节，只告诉怎么调用，怎么使用即可。具体实现以及属性的可修改权限尽可能的隐藏掉。</p>
<h3 id="第二十八条：通过协议提供匿名对象"><a href="#第二十八条：通过协议提供匿名对象" class="headerlink" title="第二十八条：通过协议提供匿名对象"></a>第二十八条：通过协议提供匿名对象</h3><ol>
<li>协议可以在某种程度上提供匿名对象，例如<code>id&lt;someProtocal&gt; object</code>。object对象的类型不限，只要能遵从这个协议即可，在这个协议里面定义了这个对象所应该实现的方法。</li>
<li>如果具体类型不重要，重要的是对象能否处理好一些特定的方法，那么就可以使用这种协议匿名对象来完成。</li>
</ol>
<hr>
<h2 id="第五章：内存管理"><a href="#第五章：内存管理" class="headerlink" title="第五章：内存管理"></a>第五章：内存管理</h2><h3 id="第二十九条：理解引用计数"><a href="#第二十九条：理解引用计数" class="headerlink" title="第二十九条：理解引用计数"></a>第二十九条：理解引用计数</h3><ol>
<li>理解引用计数这个可以通过《Objective-C 高级编程》这本书中的例子来理解，比较直观，大概如下：</li>
</ol>
<p><img src="http://upload-images.jianshu.io/upload_images/1457495-a2a2c38354a2af20.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<table>
<thead>
<tr>
<th>对照明设备所做的工作</th>
<th>对OC对象所做的动作</th>
</tr>
</thead>
<tbody>
<tr>
<td>开灯</td>
<td>生成对象</td>
</tr>
<tr>
<td>需要照明</td>
<td>持有</td>
</tr>
<tr>
<td>不需要照明</td>
<td>释放</td>
</tr>
<tr>
<td>关灯</td>
<td>废弃</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>内存管理的思考方式</th>
<th>对应OC方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>自己生成的对象，自己所持有</td>
<td>alloc/new/copy/mutableCopy等</td>
</tr>
<tr>
<td>非自己生成的对象(比如[NSArray array])，自己也能持有</td>
<td>retain </td>
</tr>
<tr>
<td>不再需要自己持有的对象时释放</td>
<td>release</td>
</tr>
<tr>
<td>当对象不被任何其他对象持有时废弃</td>
<td>dealloc</td>
</tr>
</tbody>
</table>
<ol>
<li>自动释放池: 可以看到在我们程序中入口文件main.m中main函数中就包裹了一层autoreleasepool<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">int main(int argc, char * argv[]) &#123;</div><div class="line">    @autoreleasepool &#123;</div><div class="line">        return UIApplicationMain(argc, argv, nil, NSStringFromClass([HSAppDelegate class]));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>autoreleasepool可以延长对象的生命期，使其在跨越方法调用边界后依然可以存活一段时间，通常是在下一次“时间循环”（event loop）时释放，不过也可能会执行的早一点。</p>
<ol>
<li>保留环: 也称retain cycle，就是循环引用。形成原因就是对象之间相互用强引用指向对方，会使得全部都无法得以释放。解决方案通常是使用弱引用（weak reference)</li>
</ol>
<h3 id="第三十条：以ARC简化引用计数"><a href="#第三十条：以ARC简化引用计数" class="headerlink" title="第三十条：以ARC简化引用计数"></a>第三十条：以ARC简化引用计数</h3><p>使用ARC，可以省略对于引用计数的操作，所以在ARC下调用对象的retain，release，autorelease，dealloc方法时系统会报错。<br>这里要注意CoreFoundation 对象不归ARC管理，开发中如果有用到还是要谁创建谁释放，适时调用CFRetain/CFRelease。</p>
<h3 id="第三十一条：在delloc方法中只释放引用并解除监听"><a href="#第三十一条：在delloc方法中只释放引用并解除监听" class="headerlink" title="第三十一条：在delloc方法中只释放引用并解除监听"></a>第三十一条：在delloc方法中只释放引用并解除监听</h3><p>不要在delloc方法中调用其他方法，尤其是需要异步执行某些任务又要回调的方法，这样的很危险的行为，很可能异步执行完回调的时候该对象已经被销毁了，这样就没得玩了，crash了。<br>在delloc方法里应该制作一些释放相关的事情，包括不限于一些KVO取消订阅，remove 通知等。</p>
<h3 id="第三十二条：编写“异常安全代码”时留意内存管理问题"><a href="#第三十二条：编写“异常安全代码”时留意内存管理问题" class="headerlink" title="第三十二条：编写“异常安全代码”时留意内存管理问题"></a>第三十二条：编写“异常安全代码”时留意内存管理问题</h3><p>这条有点重复，之前已经说过了，OC中抛出异常的时候可能会引起内存泄漏，注意一下使用的时机，或者注意在@try捕获异常中清理干净。</p>
<h3 id="第三十三条：以弱引用避免保留环"><a href="#第三十三条：以弱引用避免保留环" class="headerlink" title="第三十三条：以弱引用避免保留环"></a>第三十三条：以弱引用避免保留环</h3><p>这条比较简单，内容主旨就是标题：以弱引用避免保留环(Retain Cycle)</p>
<h3 id="第三十四条：以“-autoreleasepool”降低内存峰值"><a href="#第三十四条：以“-autoreleasepool”降低内存峰值" class="headerlink" title="第三十四条：以“@autoreleasepool”降低内存峰值"></a>第三十四条：以“@autoreleasepool”降低内存峰值</h3><p>在遍历处理一些大数组或者大字典的时候，可以使用自动释放池来降低内存峰值，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">NSArray *people = /*一个很大的数组*/</div><div class="line">NSMutableArray *employeesArray = [NSMutableArray new];</div><div class="line">for (NSStirng *name in people) &#123;</div><div class="line">    @autoreleasepool &#123;</div><div class="line">        MLEmployee *employee = [MLEmployee alloc] initWithName:name];</div><div class="line">        [employeesArray addObject:employee];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="第三十五条：用“僵尸对象”调试内存管理问题"><a href="#第三十五条：用“僵尸对象”调试内存管理问题" class="headerlink" title="第三十五条：用“僵尸对象”调试内存管理问题"></a>第三十五条：用“僵尸对象”调试内存管理问题</h3><p><img src="http://upload-images.jianshu.io/upload_images/1457495-586f50d111cab802.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>如上图，勾选这里可以开启僵尸对象设置。开启之后，系统在回收对象时，不将其真正的回收，而是把它的isa指针指向特殊的僵尸类，变成僵尸对象。僵尸类能够响应所有的选择子，响应方式为：打印一条包含消息内容以及其接收者的消息，然后终止应用程序</p>
<h3 id="第三十六条：不要使用retainCount"><a href="#第三十六条：不要使用retainCount" class="headerlink" title="第三十六条：不要使用retainCount"></a>第三十六条：不要使用retainCount</h3><p>在苹果引入ARC之后retainCount已经正式废弃，任何时候都不要调用这个retainCount方法来查看引用计数了，因为这个值实际上已经没有准确性了。但是在MRC下还是可以正常使用</p>
<hr>
<h2 id="第六章：Block与GCD"><a href="#第六章：Block与GCD" class="headerlink" title="第六章：Block与GCD"></a>第六章：Block与GCD</h2><h3 id="第三十七条：理解block"><a href="#第三十七条：理解block" class="headerlink" title="第三十七条：理解block"></a>第三十七条：理解block</h3><p>根据block在内存中的位置，block被分成三种类型：</p>
<ol>
<li><p>NSGlobalBlock 全局块:<br>这种块运行时无需获取外界任何状态，块所使用的内存区域在编译器就可以完全确定，所以该块声明在全局内存中。如果全局块执行copy会是一个空操作，相当于什么都没做。全局块例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">void (^block)() = ^&#123;</div><div class="line">    NSLog(@&quot;I am a NSGlobalBlock&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>NSStackBlock  栈块:<br>栈块保存于栈区，超出变量作用域，栈上的block以及__block变量都会被销毁。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">NSString *name = @&quot;PHP&quot;;</div><div class="line">void (^block)() = ^&#123;</div><div class="line">    NSLog(@&quot;世界上最好的编程语言是%@&quot;, name);</div><div class="line">&#125;;</div><div class="line">NSLog(@&quot;%@&quot;, block);</div></pre></td></tr></table></figure>
</li>
</ol>
<p>运行下你会发现控制台打印的是:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;__NSStackBlock__: 0x7fff5480fa18&gt;</div></pre></td></tr></table></figure></p>
<p>什么，你说什么，你打印出来的是<code>__ NSMallocBlock __</code>? 那是因为你在ARC下编译的，ARC下编译器编译时会帮你优化自动帮你加上了copy操作，你可以用<code>-fno-objc-arc</code>关闭ARC再看一下</p>
<ol>
<li>NSMallocBlock  堆块:<br><em>NSMallocBlock内心独白：我已经被暴露了，为什么要最后才介绍我！！</em><br>堆block内存保存于堆区，在变量作用域结束时不受影响。通过之前在ARC下的输出已经看到了<strong> NSMallocBlock </strong>.所以我们在定义block类型的属性时常常加上copy修饰，这个修饰其实是多余的，系统在ARC的时候已经帮我们做了copy，但是还是建议写上copy。</li>
</ol>
<h3 id="第三十八条：为常用的块类型创建typedef"><a href="#第三十八条：为常用的块类型创建typedef" class="headerlink" title="第三十八条：为常用的块类型创建typedef"></a>第三十八条：为常用的块类型创建typedef</h3><p>这条主要是为了代码更易读，也比较重要。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (void)getDataWithHost:(NSString *)host success:(void (^)(id responseDic))success;</div><div class="line">//以上要改成下面这种</div><div class="line">typedef void (^SuccessBlock)(id responseDic);</div><div class="line">- (void)getDataWithHost:(NSString *)host success:(SuccessBlock)success;</div></pre></td></tr></table></figure></p>
<h3 id="第三十九条：用handler块降低代码分散程度"><a href="#第三十九条：用handler块降低代码分散程度" class="headerlink" title="第三十九条：用handler块降低代码分散程度"></a>第三十九条：用handler块降低代码分散程度</h3><p>在iOS开发中，我们经常需要异步执行一些任务，然后等待任务执行结束之后通知相关方法。实现此需求的做法很多，比如说有些人可能会选择用委托协议。那么在这种异步执行一些任务，然后等待执行结束之后调用代理的时候，可能代码就会比较分散。当多个任务都需要异步，等等就显得比较不那么合理了。<br>所以我们可以考虑使用block的方式设计，这样业务相关的代码会比较紧凑，不会显得那么凌乱。</p>
<h3 id="第四十条：用块引用其所属对象是不要出现保留环"><a href="#第四十条：用块引用其所属对象是不要出现保留环" class="headerlink" title="第四十条：用块引用其所属对象是不要出现保留环"></a>第四十条：用块引用其所属对象是不要出现保留环</h3><p>这点比较基础了，但是要稍微说一下，不是一定得在block中使用weakself，比如下面：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[YTKNetwork requestBlock:^(id responsObject) &#123;</div><div class="line">      NSLog(@&quot;%@&quot;,self.name);</div><div class="line">  &#125;];</div></pre></td></tr></table></figure></p>
<p>block 不是被self所持有的，在block中就可以使用self</p>
<h3 id="第四十一条：多用派发队列，少用同步锁"><a href="#第四十一条：多用派发队列，少用同步锁" class="headerlink" title="第四十一条：多用派发队列，少用同步锁"></a>第四十一条：多用派发队列，少用同步锁</h3><p>在iOS开发中，如果有多个线程要执行同一份代码，我们可能需要加锁来实现某种同步机制。有人可能第一印象想到的就是<code>@synchronized(self)</code>，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">- (NSString*)someString &#123;</div><div class="line">    @synchronized(self) &#123;</div><div class="line">        return _someString;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">- (void)setSomeString:(NSString*)someString &#123;</div><div class="line">     @synchronized(self) &#123;</div><div class="line">        _someString = someString;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样写法效率很低，而且也不能保证线程中觉得的安全。如果有很多属性，那么每个属性的同步块都要等其他同步块执行完毕才能执行。<br>应该用GCD来替换：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">_syncQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</div><div class="line"></div><div class="line">//读取字符串</div><div class="line">- (NSString*)someString &#123;</div><div class="line">    __block NSString *localSomeString;</div><div class="line">     dispatch_sync(_syncQueue, ^&#123;</div><div class="line">        localSomeString = _someString;</div><div class="line">    &#125;);</div><div class="line">     return localSomeString;</div><div class="line">&#125;</div><div class="line">- (void)setSomeString:(NSString*)someString &#123;</div><div class="line">     dispatch_barrier_async(_syncQueue, ^&#123;</div><div class="line">        _someString = someString;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="第四十二条：多用GCD，少用performSelector系列方法"><a href="#第四十二条：多用GCD，少用performSelector系列方法" class="headerlink" title="第四十二条：多用GCD，少用performSelector系列方法"></a>第四十二条：多用GCD，少用performSelector系列方法</h3><p>Objective-C本质上是一门分厂动态的语言，开发者在开发中可以指定任何一个方法去调用，也可以延迟调用一些方法，或者指定运行方法的线程。一般我们会想到<code>performSelector</code>，但是在GCD出来之后基本就没那么需要<code>performSelector</code>了，<code>performSelector</code>也有很多缺点：</p>
<ol>
<li>内存管理问题：在ARC下使用<code>performSelector</code>我们经常会看到编译器发出如下警告：<code>warning: performSelector may cause a leak because its selector is unknown [-Warc-performSelector-leaks]</code></li>
<li><code>performSelector</code>的返回值只能是void或对象类型。</li>
<li><code>performSelector</code>无法处理带有多个参数的选择子，最多只能处理两个参数。<br>为了改变这些，我们可以用下面这种方式</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">        [self doSomething];</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>替换掉<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[self performSelectorOnMainThread:@selector(doSomething) </div><div class="line">                       withObject:nil </div><div class="line">                    waitUntilDone:NO];</div></pre></td></tr></table></figure></p>
<p>然后还可以用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, </div><div class="line">                                (int64_t)(5.0 * NSEC_PER_SEC));</div><div class="line">dispatch_after(time, dispatch_get_main_queue(), ^(void)&#123;</div><div class="line">    [self doSomething];</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>替换<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[self performSelector:@selector(doSomething) </div><div class="line">           withObject:nil </div><div class="line">           afterDelay:5.0];</div></pre></td></tr></table></figure></p>
<h3 id="第四十三条：掌握GCD以及操作队列的使用时机"><a href="#第四十三条：掌握GCD以及操作队列的使用时机" class="headerlink" title="第四十三条：掌握GCD以及操作队列的使用时机"></a>第四十三条：掌握GCD以及操作队列的使用时机</h3><p>GCD技术确实很棒，但是也有一些局限性，或者说有一些场景并不适合。比如过想取消队列中的某个操作，或者需要后台执行任务。还有一种技术叫<code>NSOperationQueue</code>，其实<code>NSOperationQueue</code>跟GCD有很多相像之处。<code>NSOperationQueue</code>在GCD之前就已经有了，GCD就是在其某些原理上构建的。GCD是C层次的API，而<code>NSOperation</code>是重量级的Objective-C对象。<br>使用<code>NSOperation</code>和<code>NSOperationQueue</code>的优点：</p>
<ol>
<li>支持取消某个操作：在运行任务前，可以在NSOperation对象上调用<code>cancel方法</code>，用以表明此任务不需要执行。不过已经启动的任务无法取消。GCD队列是无法取消的，GCD是“安排好之后就不管了（fire and forget）”。</li>
<li>支持指定操作间的依赖关系：一个操作可以依赖其他多个操作，例如从服务器下载并处理文件的动作可以用操作来表示，而在处理其他文件之前必须先下载“清单文件”。而后续的下载工作，都要依赖于先下载的清单文件这一操作。这时如果操作队列允许并发执行的话，后续的下载操作就可以在他依赖的<code>下载清单文件操作</code>执行完毕之后开始同时执行。</li>
<li>支持通过KVO监控NSOperation对象的属性：可以通过isCancelled属性来判断任务是否已取消，通过isFinished属性来判断任务是否已经完成等等。</li>
<li>支持指定操作的优先级：操作的优先级表示此操作与队列中其他操作之间的优先关系，优先级搞的操作先执行，优先级低的后执行。GCD的队列也有优先级，不过不是针对整个队列的。</li>
<li>重用NSOperation对象。在开发中你可以使用NSOperation的子类或者自己创建NSOperation对象来保存一些信息，可以在类中定义方法，使得代码能够多次使用。不必重复自己。</li>
</ol>
<h3 id="第四十四条：通过Dispatch-Group机制，根据系统资源状况来执行任务"><a href="#第四十四条：通过Dispatch-Group机制，根据系统资源状况来执行任务" class="headerlink" title="第四十四条：通过Dispatch Group机制，根据系统资源状况来执行任务"></a>第四十四条：通过Dispatch Group机制，根据系统资源状况来执行任务</h3><p>这条主要是介绍dispatch group，任务分组的功能。他可以把任务分组，然后等待这组任务执行完毕时会有通知，开发者可以拿到结果然后继续下一步操作。<br>另外通过dispatch group在并发队列上同时执行多项任务的时候，GCD会根据系统资源状态来帮忙调度这些并发执行的任务。</p>
<h3 id="第四十五条：使用dispatch-once来执行只需要运行一次的线程安全代码"><a href="#第四十五条：使用dispatch-once来执行只需要运行一次的线程安全代码" class="headerlink" title="第四十五条：使用dispatch_once来执行只需要运行一次的线程安全代码"></a>第四十五条：使用dispatch_once来执行只需要运行一次的线程安全代码</h3><p>这条讲的是常用的dispatch_once<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">+ (id)sharedInstance &#123;</div><div class="line">     static EOCClass *sharedInstance = nil;</div><div class="line">     static dispatch_once_t onceToken;</div><div class="line">     dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">﻿            sharedInstance = [[self alloc] init];</div><div class="line">    &#125;);</div><div class="line">     return sharedInstance;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>dispatch_once比较高效，没有重量级的同步机制。</p>
<h3 id="第四十六条：不要使用dispatch-get-current-queue"><a href="#第四十六条：不要使用dispatch-get-current-queue" class="headerlink" title="第四十六条：不要使用dispatch_get_current_queue"></a>第四十六条：不要使用dispatch_get_current_queue</h3><ol>
<li>dispatch_get_current_queue 函数的行为常常与开发者所预期的不同，此函数已经废弃，只应做调试之用。</li>
<li>由于GCD是按层级来组织的，所以无法单用某个队列对象来描述”当前队列”这一概念。</li>
<li>dispatch_get_current_queue 函数用于解决由不可以重入的代码所引发的死锁，然后能用此函数解决的问题，通常也可以用”队列特定数据”来解决。</li>
</ol>
<hr>
<h2 id="第七章：系统框架"><a href="#第七章：系统框架" class="headerlink" title="第七章：系统框架"></a>第七章：系统框架</h2><h3 id="第四十七条：熟悉系统框架"><a href="#第四十七条：熟悉系统框架" class="headerlink" title="第四十七条：熟悉系统框架"></a>第四十七条：熟悉系统框架</h3><p>在Objective-C中除了Foundation 与CoreFoundation之外还有很多系统库，其中包括但不限于下面列出的这些：</p>
<ol>
<li>CFNetwork:此框架提供了C语言级别的网络通信能力，它将BSD socket抽象成了易于使用的网络接口。而Foundation则将该框架里的部分内容封装为Objective-C接口，以便进行网络通信。</li>
<li>CoreAudio:此框架所提供的C语言API可以用来操作设备上的音频硬件。</li>
<li>AVFoundation:此框架所提供的Objective-C对象可用来回访并录制音频及视频，比如能够在UI视图类里播放视频。</li>
<li>CoreData:此框架所提供的Objective-C接口可以将对象放入数据库，将数据持久化。</li>
<li>CoreText:此框架提供的C语言接口可以高效执行文字排版以及渲染操作。</li>
<li>SpriteKit :游戏框架</li>
<li>CoreLocation、MapKit :定位地图相关框架</li>
<li>Address Book框架:需要使用通讯录时才使用该框架</li>
<li>Music Libraries框架:音乐库相关框架</li>
<li>HealthKit框架：健康相关框架</li>
<li>HomeKit框架：为智能化硬件提供的框架</li>
<li>CloudKit : iCloud相关的框架</li>
<li>Passbook、PassKit框架：为了在应用中用户可以很容易的访问他们之前购买的活动门票、旅行车票、优惠券等等提供的框架</li>
</ol>
<h3 id="第四十八条：多用块枚举，少用for循环"><a href="#第四十八条：多用块枚举，少用for循环" class="headerlink" title="第四十八条：多用块枚举，少用for循环"></a>第四十八条：多用块枚举，少用for循环</h3><ol>
<li>遍历collection中的元素有四种方式，最基本的办法就是for循环，其次是NSEnumerator遍历法，还有快速遍历法（for in），以及块枚举法。块枚举是最新，最先进的方式。</li>
<li>块枚举法是通过GCD来并发执行遍历操作</li>
<li>若提前知道待遍历的collection含有何种对象，则应修改块签名，指出对象的具体类型。</li>
</ol>
<h3 id="第四十九条：对自定义其内存管理语义的collecion使用无缝桥接"><a href="#第四十九条：对自定义其内存管理语义的collecion使用无缝桥接" class="headerlink" title="第四十九条：对自定义其内存管理语义的collecion使用无缝桥接"></a>第四十九条：对自定义其内存管理语义的collecion使用无缝桥接</h3><p>通过无缝桥接技术，可以在定义于Foundation框架中的类和CoreFoundation框架中的C语言数据结构之间来回转换。<br>下面代码展示了简单的无缝桥接：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">NSArray *anNSArray = @[@1, @2, @3, @4, @5];</div><div class="line">CFArrayRef aCFArray = (__bridge CFArrayRef)anNSArray;</div><div class="line">NSLog(@&quot;Size of array = %li&quot;, CFArrayGetCount(aCFArray));</div><div class="line">//Output: Size of array = 5</div></pre></td></tr></table></figure></p>
<p>转换操作中的<code>__bridge</code>告诉ARC如何传力转换所涉及的OC对象，也就是ARC仍然具备这个OC对象的所有权。<code>__bridge_retained</code>与之相反。这里要注意用完了数组要自己释放，使用<code>CFRelease(aCFArray)</code>前面有提到过的。</p>
<h3 id="第五十条：构建缓存时选用NSCache而非NSDictionary"><a href="#第五十条：构建缓存时选用NSCache而非NSDictionary" class="headerlink" title="第五十条：构建缓存时选用NSCache而非NSDictionary"></a>第五十条：构建缓存时选用NSCache而非NSDictionary</h3><p>在构建缓存时应该尽量选用NSCache而非NSDictionary，NSCache会在系统资源将要耗尽时自动删减缓存，而使用NSDictionary只能通过系统低内存警告方法去手动处理。此外NSCache还会看情况删减最久未使用的对象，而且是线程安全的。</p>
<h3 id="第五十一条：精简initialize与load的实现代码"><a href="#第五十一条：精简initialize与load的实现代码" class="headerlink" title="第五十一条：精简initialize与load的实现代码"></a>第五十一条：精简initialize与load的实现代码</h3><ol>
<li>load与initialize 方法都应该实现的精简一点，这样有助于保持应用程序的响应能力，也可以减少引入依赖环的几率</li>
<li>无法在编译器设定的全局常量，可以放在initialize方法里面初始化。<br>另外没搞清楚load 与 initialize的可以看这里， 我之前有出过一道有点脑残有点绕的题（别拍砖，😆），<a href="http://www.jianshu.com/p/ffdefa76e4a2" target="_blank" rel="external">可以点击这里查看</a></li>
</ol>
<h3 id="第五十二条：别忘了NSTimer会保留其目标对象"><a href="#第五十二条：别忘了NSTimer会保留其目标对象" class="headerlink" title="第五十二条：别忘了NSTimer会保留其目标对象"></a>第五十二条：别忘了NSTimer会保留其目标对象</h3><p>在iOS开发中经常会用到定时器:NSTimer，由于NSTimer会生成指向其使用者的引用，而其使用者如果也引用了NSTimer，那就形成了该死的循环引用，比如下面这个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@interface EOCClass : NSObject</div><div class="line">- (void)startPolling;</div><div class="line">- (void)stopPolling;</div><div class="line">@end</div><div class="line">@implementation EOCClass &#123;</div><div class="line">     NSTimer *_pollTimer;</div><div class="line">&#125;</div><div class="line">- (id)init &#123;</div><div class="line">     return [super init];</div><div class="line">&#125;</div><div class="line">- (void)dealloc &#123;</div><div class="line">    [_pollTimer invalidate];</div><div class="line">&#125;</div><div class="line">- (void)stopPolling &#123;</div><div class="line"></div><div class="line">    [_pollTimer invalidate];</div><div class="line">    _pollTimer = nil;</div><div class="line">&#125;</div><div class="line">- (void)startPolling &#123;</div><div class="line">   _pollTimer = [NSTimer scheduledTimerWithTimeInterval:5.0</div><div class="line">                                                 target:self</div><div class="line">                                               selector:@selector(p_doPoll)</div><div class="line">                                               userInfo:nil</div><div class="line">                                                repeats:YES];</div><div class="line">&#125;</div><div class="line">- (void)p_doPoll &#123;</div><div class="line">    // Poll the resource</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>如果创建了本类的实例，并调用其startPolling方法开始定时器，由于目标对象是self，所以要保留此实例，因为定时器是用成员变量存放的，所以self也保留了计时器，所以此时存在保留环。此时要么调用<code>stopPolling</code>，要么令系统将此实例回收，只有这样才能打破保留环。<br>这是一个很常见的内存泄漏，那么怎么解决呢？这个问题可以通过block来解决。可以添加这样的一个分类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line">//.h</div><div class="line">@interface NSTimer (EOCBlocksSupport)</div><div class="line"></div><div class="line">+ (NSTimer*)eoc_scheduledTimerWithTimeInterval:(NSTimeInterval)interval</div><div class="line">                                         block:(void(^)())block</div><div class="line">                                         repeats:(BOOL)repeats;</div><div class="line">@end</div><div class="line">//.m</div><div class="line">@implementation NSTimer (EOCBlocksSupport)</div><div class="line"></div><div class="line">+ (NSTimer*)eoc_scheduledTimerWithTimeInterval:(NSTimeInterval)interval</div><div class="line">                                         block:(void(^)())block</div><div class="line">                                        repeats:(BOOL)repeats</div><div class="line">&#123;</div><div class="line">             return [self scheduledTimerWithTimeInterval:interval</div><div class="line">                                                  target:self</div><div class="line">                                                selector:@selector(eoc_blockInvoke:)</div><div class="line">                                                userInfo:[block copy]</div><div class="line">                                                 repeats:repeats];</div><div class="line"></div><div class="line">&#125;</div><div class="line">+ (void)eoc_blockInvoke:(NSTimer*)timer &#123;</div><div class="line">     void (^block)() = timer.userInfo;</div><div class="line">         if (block) &#123;</div><div class="line">             block();</div><div class="line">        &#125;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<hr>
<p><strong>EOF :</strong> 由于个人能力有限，难免有一些遗漏或者错误，请各位看官不吝赐教！谢谢！同时如果有任何问题也可以在下方留言，欢迎一起交流进步~最后感谢作者Matt Galloway以及译者！更多细节还是请翻阅图书，可以<a href="https://pan.baidu.com/s/1bpCj0i7" target="_blank" rel="external">点击这里下载</a>PDF版，原版英文版PDF我也有存~本文已经同步到<a href="http://www.superma.me/2017/08/06/%E9%87%8D%E6%B8%A9%E3%80%8AEffectiveObjective-C2-0%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FiOS%E4%B8%8EOSX%E4%BB%A3%E7%A0%81%E7%9A%8452%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95%E3%80%8B/" target="_blank" rel="external">个人博客</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在重温这本OC经典之作《Effective Objective-C 2.0编写高质量iOS与OS X代码的52个有效方法》，这篇文章算是重温之后的产物吧
    
    </summary>
    
      <category term="Objective-C" scheme="http://superma.me/all-categories/Objective-C/"/>
    
    
      <category term="Effective-OC" scheme="http://superma.me/all-tags/Effective-OC/"/>
    
  </entry>
  
  <entry>
    <title>iOS理解Objective-C中消息转发机制附Demo</title>
    <link href="http://superma.me/2017/07/30/iOS%E7%90%86%E8%A7%A3Objective-C%E4%B8%AD%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91%E6%9C%BA%E5%88%B6%E9%99%84Demo/"/>
    <id>http://superma.me/2017/07/30/iOS理解Objective-C中消息转发机制附Demo/</id>
    <published>2017-07-30T07:35:00.000Z</published>
    <updated>2017-08-05T17:23:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在重温Effective Objective-C 2.0，这篇文章属于重温的产物吧，本文会通过demo来讲解OC中的消息转发机制</p>
<a id="more"></a>
<p><img src="http://upload-images.jianshu.io/upload_images/1457495-ade801c636fc86fc.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>Demo:<a href="https://github.com/maligh/ML-Objective-C-Demo/tree/master/MessageForwarding" target="_blank" rel="external">点我查看,觉得有帮助的话不要吝惜你的star</a><br>话不多说，iOS开发过程中我们经常会碰到这样的报错：<code>unrecognized selector sent to instance **</code>，原因是我们调用了一个不存在的方法。用OC消息机制来说就是：消息的接收者不过到对应的selector，这样就启动了消息转发机制，我们可以通过代码在消息转发的过程中告诉对象应该如何处理未知的消息，默认实现是抛出下面的异常</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1457495-960047111dbd1c57.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="unrecognized selector.png"><br>下面我们通过实例来看一下在抛出异常之前也就是消息转发过程中都经过了哪些步骤：</p>
<hr>
<p>第一步：对象在收到无法解读的消息后，首先会调用<code>+(BOOL)resolveInstanceMethod:(SEL)sel</code>或者<code>+ (BOOL)resolveClassMethod:(SEL)sel</code>, 询问是否有动态添加方法来进行处理，处理实例如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">//People.m</div><div class="line">void speak(id self, SEL _cmd)&#123;</div><div class="line">    NSLog(@&quot;Now I can speak.&quot;);</div><div class="line">&#125;</div><div class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel &#123;</div><div class="line">    </div><div class="line">    NSLog(@&quot;resolveInstanceMethod:  %@&quot;, NSStringFromSelector(sel));</div><div class="line">    if (sel == @selector(speak)) &#123;</div><div class="line">        class_addMethod([self class], sel, (IMP)speak, &quot;V@:&quot;);</div><div class="line">        return YES;</div><div class="line">    &#125;</div><div class="line">    return [super resolveInstanceMethod:sel];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当People 收到了未知 speak选择子的消息的时候，如果是实例方法会首选调用上文的<code>resolveInstanceMethod:</code>方法，方法内通过判断选择子然后通过<code>class_addMethod</code>方法动态添加了一个speak的实现方法来解决掉这条未知的消息，此时消息转发过程提前结束。<br>但是当People 收到fly 这条未知消息的时候，第一步返回的是No，也就是没有动态新增实现方法的时候就会调用第二步</p>
<hr>
<p>第二步：既然第一步已经问过了，没有新增方法，那就问问有没有别人能够帮忙处理一下啊，调用的是<code>- (id)forwardingTargetForSelector:(SEL)aSelector</code>这个方法<br>上文我们说到People接收到了一条选择子为<code>fly</code>的未知消息，我们可以看到控制台已经打印了<code>resolveInstanceMethod:  fly</code>，代表第一步已经问过了，那么第二步问一下是否有别的类能帮忙处理吗？代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (id)forwardingTargetForSelector:(SEL)aSelector &#123;</div><div class="line">    NSLog(@&quot;forwardingTargetForSelector:  %@&quot;, NSStringFromSelector(aSelector));</div><div class="line">    Bird *bird = [[Bird alloc] init];</div><div class="line">    if ([bird respondsToSelector: aSelector]) &#123;</div><div class="line">        return bird;</div><div class="line">    &#125;</div><div class="line">    return [super forwardingTargetForSelector: aSelector];</div><div class="line">&#125;</div><div class="line">// Bird.m</div><div class="line">- (void)fly &#123;</div><div class="line">    NSLog(@&quot;I am a bird, I can fly.&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过<code>- (id)forwardingTargetForSelector:(SEL)aSelector</code>的处理，bird能够处理这条消息，所以这条消息被bird成功处理，消息转发流程提前结束。控制台打印<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">forwardingTargetForSelector:  fly</div><div class="line">I am a bird, I can fly.</div></pre></td></tr></table></figure></p>
<p>但是如果<code>- (id)forwardingTargetForSelector:(SEL)aSelector</code>也找不到能够帮忙处理这条未知消息，那就会走到最后一步，这步也是代价最大的一步</p>
<hr>
<p>第三步：调用<code>- (void)forwardInvocation:(NSInvocation *)anInvocation</code>，在调用<code>forwardInvocation:</code>之前会调用<code>- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</code>方法来获取这个选择子的方法签名，然后在<code>-(void)forwardInvocation:(NSInvocation *)anInvocation</code>方法中你就可以通过<code>anInvocation</code>拿到相应信息做处理，实例代码如下</p>
<p>当People 收到一条 选择子为code 的消息的时候，前两步发现都没办法处理掉，走到第三步：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation &#123;</div><div class="line">    NSLog(@&quot;forwardInvocation: %@&quot;, NSStringFromSelector([anInvocation selector]));</div><div class="line">    if ([anInvocation selector] == @selector(code)) &#123;</div><div class="line">        Monkey *monkey = [[Monkey alloc] init];</div><div class="line">        [anInvocation invokeWithTarget:monkey];</div><div class="line">    &#125;   </div><div class="line">&#125;</div><div class="line"></div><div class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123;</div><div class="line">    NSLog(@&quot;method signature for selector: %@&quot;, NSStringFromSelector(aSelector));</div><div class="line">    if (aSelector == @selector(code)) &#123;</div><div class="line">        return [NSMethodSignature signatureWithObjCTypes:&quot;V@:@&quot;];</div><div class="line">    &#125;</div><div class="line">    return [super methodSignatureForSelector:aSelector];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这时控制台会打印<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">resolveInstanceMethod:  code</div><div class="line">forwardingTargetForSelector:  code</div><div class="line">method signature for selector: code</div><div class="line">forwardInvocation: code</div><div class="line">I am a coder.</div></pre></td></tr></table></figure></p>
<p>此时这个code消息已经被monkey实例处理掉<br>此时消息转发流程完整的结束了，完整的消息转发流程如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1457495-8ee6afef466e6177.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<hr>
<p>那么最后消息未能处理的时候，还会调用到<br><code>- (void)doesNotRecognizeSelector:(SEL)aSelector</code>这个方法，我们也可以在这个方法中做些文章，避免掉crash，但是只建议在线上环境的时候做处理，实际开发过程中还要把异常抛出来</p>
<p>EOF:OC中消息转发流程大概就是这样了，Demo<a href="https://github.com/maligh/ML-Objective-C-Demo/tree/master/MessageForwarding" target="_blank" rel="external">点这里，觉得有帮助的话不要吝惜你的star</a>，由于个人能力有限，文中难免有些错误，希望大家不吝赐教~<br>另外有一个问题想问大家，+ (BOOL)resolveClassMethod:(SEL)sel 在这个方法中怎么动态添加类方法？ 比如我发送了一条未知的 [People missMethod]消息，怎么添加 +(void)missMethod 的实现呢？</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在重温Effective Objective-C 2.0，这篇文章属于重温的产物吧，本文会通过demo来讲解OC中的消息转发机制&lt;/p&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="http://superma.me/all-categories/Objective-C/"/>
    
    
      <category term="消息转发" scheme="http://superma.me/all-tags/%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C编程规范以及建议</title>
    <link href="http://superma.me/2017/07/04/Objective-C%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83%E4%BB%A5%E5%8F%8A%E5%BB%BA%E8%AE%AE/"/>
    <id>http://superma.me/2017/07/04/Objective-C编程规范以及建议/</id>
    <published>2017-07-04T15:36:51.000Z</published>
    <updated>2017-07-04T16:49:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录一下Objective-C编程规范以及一些建议，可能后续会有些修改和补充，至于初衷是最近接手的项目中代码”有些”凌乱，所以整理了一篇，有一些来自网上，有一些是我平时的代码风格的吧~<br><a id="more"></a><br><img src="http://upload-images.jianshu.io/upload_images/1457495-ad0b17b8f89cc097.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Flag"></p>
<h2 id="方法声明和定义"><a href="#方法声明和定义" class="headerlink" title="方法声明和定义"></a>方法声明和定义</h2><p>-或者+和返回类型之间须使用一个空格，括号要同行并有一个空格</p>
<p>方法应该像这样：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)doSomethingWithString:(<span class="built_in">NSString</span> *)theString &#123;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果函数名字太长，可以用冒号对齐，像这样：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)doSomethingWith:(GTMFoo *)theFoo</div><div class="line">                   rect:(<span class="built_in">NSRect</span>)theRect</div><div class="line">               interval:(<span class="keyword">float</span>)theInterval &#123;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当第一个关键字比其它的短时,要保证下一行至少有4个空格的缩进，对齐关键字，像这样：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)<span class="keyword">short</span>:(GTMFoo *)theFoo</div><div class="line">    longKeyword:(<span class="built_in">NSRect</span>)theRect</div><div class="line">    evenLongerKeyword:(<span class="keyword">float</span>)theInterval &#123;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h2><p>调用时所有参数应该在同一行：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[myObject doFooWith:arg1 name:arg2 error:arg3];</div></pre></td></tr></table></figure>
<p>或者每行一个参数，以冒号对齐：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[myObject doFooWith:arg1</div><div class="line">               name:arg2</div><div class="line">              error:arg3];</div></pre></td></tr></table></figure>
<p>方法定义与方法声明一样，当关键字的长度不足以以冒号对齐时，下一行都要以四个空格进行缩进</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[myObj <span class="keyword">short</span>:arg1</div><div class="line">    longKeyword:arg2</div><div class="line">    evenLongerKeyword:arg3];</div></pre></td></tr></table></figure>
<p>不要使用下面的缩进风格：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">[myObject doFooWith:arg1 name:arg2  <span class="comment">// some lines with &gt;1 arg</span></div><div class="line">              error:arg3];</div><div class="line"></div><div class="line">[myObject doFooWith:arg1</div><div class="line">               name:arg2 error:arg3];</div><div class="line"></div><div class="line">[myObject doFooWith:arg1</div><div class="line">          name:arg2  <span class="comment">// aligning keywords instead of colons</span></div><div class="line">          error:arg3];</div></pre></td></tr></table></figure>
<hr>
<h2 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h2><p>对于易维护的代码而言，命名规则非常重要。Objective-C 的方法名往往十分长，但代码块读起来就像散文一样，不需要太多的代码注释</p>
<p>当编写纯粹的 Objective-C 代码时，我们基本遵守标准的 <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CodingGuidelines/CodingGuidelines.html" target="_blank" rel="external">Objective-C naming rules</a>,</p>
<h2 id="文件名"><a href="#文件名" class="headerlink" title="文件名"></a>文件名</h2><table>
<thead>
<tr>
<th>扩展名</th>
<th>文件分类</th>
</tr>
</thead>
<tbody>
<tr>
<td>.h</td>
<td>C/C++/Objective-C 的头文件</td>
</tr>
<tr>
<td>.m</td>
<td>Objective-C 实现文件</td>
</tr>
<tr>
<td>.mm</td>
<td>Ojbective-C++ 的实现文件</td>
</tr>
<tr>
<td>.cc</td>
<td>纯 C++ 的实现文件</td>
</tr>
<tr>
<td>.c</td>
<td>纯C 的实现文件</td>
</tr>
</tbody>
</table>
<h2 id="类名"><a href="#类名" class="headerlink" title="类名"></a>类名</h2><p>类名（以及类别、协议名）应首字母大写，并以驼峰格式分割单词</p>
<h2 id="Objective-C-方法名"><a href="#Objective-C-方法名" class="headerlink" title="Objective-C 方法名"></a>Objective-C 方法名</h2><p>方法名应该以小写字母开头，并混合驼峰格式。每个具名参数也应该以小写字母开头<br>方法名应尽量读起来就像句子，这表示你应该选择与方法名连在一起读起来通顺的参数名。（例如，convertPoint:fromRect: 或 replaceCharactersInRange:withString:）。详情参见 <a href="http://developer.apple.com/documentation/Cocoa/Conceptual/CodingGuidelines/Articles/NamingMethods.html" target="_blank" rel="external">Apple’s Guide to Naming Methods</a><br>第二个参数不要<code>and</code>：</p>
<ul>
<li>正确: <code>- (instancetype)initWithWidth:(float)width :(float)height;</code> </li>
<li>不好: <code>- (id)initWithWidth:(float)width andHeight:(float)height;</code> </li>
</ul>
<h2 id="变量名"><a href="#变量名" class="headerlink" title="变量名"></a>变量名</h2><p>应该使用驼峰命名法，变量名尽量能够代表其自身意思，尽量避免中英文混合命名，中英文混合命名是建议用’_’下划线分割中英文。<br><strong>尽量避免如下命名方式</strong></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSDictionary</span> *d0 = [ACGPCacheCenter readFileAtSubDir: HSHomePageSubDirForAD];</div><div class="line"><span class="built_in">NSDictionary</span> *d2 = [ACGPCacheCenter readFileAtSubDir: HSHomePageSubDirForZX];</div><div class="line"><span class="built_in">NSDictionary</span> *d3 = [ACGPCacheCenter readFileAtSubDir: HSHPSubDirForEntry];</div><div class="line"><span class="built_in">NSDictionary</span> *d4 = [ACGPCacheCenter readFileAtSubDir: HSHPSubDirForCopywriting];</div></pre></td></tr></table></figure>
<p>循环以及一些生命周期很短、很浅显易懂的变量可以放开要求，可以使用简单单字母等等变量名</p>
<h2 id="常量名"><a href="#常量名" class="headerlink" title="常量名"></a>常量名</h2><p>常量名（如宏定义、枚举、静态局部变量等）应该以小写字母 k 开头，使用驼峰格式分隔单词，如：<code>kInvalidHandle，kWritePerm</code></p>
<hr>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>建议注释不要过多，尽量能够做到代码自解释。与其给类型及变量起一个晦涩难懂的名字，再为它写注释，不如直接起一个有意义的名字</p>
<p>关于注释有以下几点建议：</p>
<h3 id="h-文件注释"><a href="#h-文件注释" class="headerlink" title=".h 文件注释"></a>.h 文件注释</h3><p> <code>.h</code> 文件中 interface 前要加<code>VVDocumenter</code>注释，例如下面这个类，根据类名根本不知道哪个模块，做什么的。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">HSHPCopywritingCell</span> : <span class="title">HSBaseCollectionViewCell</span></span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>应改成</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> 首页模块-自选股cell</div><div class="line"> */</div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">HSHPCopywritingCell</span> : <span class="title">HSBaseCollectionViewCell</span></span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>之后在业务代码中遇到这个类，按住<code>alt</code>键鼠标点击类名就可以查看到类的<code>Description</code>如下：<br><img src="http://opmu2mji9.bkt.clouddn.com/123.png" alt=""></p>
<h3 id="属性以及成员变量注释"><a href="#属性以及成员变量注释" class="headerlink" title="属性以及成员变量注释"></a>属性以及成员变量注释</h3><p>属性、成员变量、枚举类型的注释建议用 <code>///&lt;</code>进行注释</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) HSMarketIndexModel *USmodel;      <span class="comment">///&lt; 美股指数model</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) HSMarketIndexModel *HKmodel;      <span class="comment">///&lt; 港股指数model</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) HSMarketIndexView *indexView;     <span class="comment">///&lt; 指数view</span></div></pre></td></tr></table></figure>
<p>同样按住<code>alt</code>键鼠标点击类名也可以查看到类的<code>Description</code>，用<code>/** 美股指数 */</code> 这种注释方式也可以看到Description，不过属性太多可能会不太美观</p>
<h3 id="代码块注释"><a href="#代码块注释" class="headerlink" title="代码块注释"></a>代码块注释</h3><p>善用<code>#pragma mark</code>把代码进行分类，<code>#pragma mark</code>没有下划线，<code>#pragma mark -</code>有下划线分割</p>
<p>建议用如下类似代码块组织代码：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#pragma mark - ================ LifeCycle =================</span></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">self</span> configUI];</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>) viewWillAppear:(<span class="built_in">BOOL</span>)animated &#123;</div><div class="line">&#125;...</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)configUI &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">#pragma mark - ================ Public Methods =================</span></div><div class="line"></div><div class="line"><span class="meta">#pragma mark ==== 核心公开方法注释</span></div><div class="line">- (<span class="keyword">void</span>)somePublicMethod &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">#pragma mark ==== 核心公开方法注释2</span></div><div class="line">- (<span class="keyword">void</span>)somePublicMethod2 &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">#pragma mark - ================ Private Methods =================</span></div><div class="line"></div><div class="line"><span class="meta">#pragma mark ==== 核心私有方法注释</span></div><div class="line">- (<span class="keyword">void</span>)somePrivateMethod &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">#pragma mark - ================ UITableView Delegate =================</span></div><div class="line"></div><div class="line">- (<span class="built_in">NSInteger</span>)numberOfSectionsInTableView:(<span class="built_in">UITableView</span> *)tableView &#123; </div><div class="line">&#125;...</div><div class="line"></div><div class="line"><span class="meta">#pragma mark - ================ Actions =================</span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)someButtonClicked &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">#pragma mark - ================ Getter and Setter =================</span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)setModelArray:(<span class="built_in">NSMutableArray</span> *)modelArray &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>注意:</strong>代码块的顺序应该是由重要到不重要，Getter之类的不重要代码块要放在最后，确保别人打开你的类先映入眼帘的是<code>有用的代码</code></p>
<hr>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="保持公共API简单"><a href="#保持公共API简单" class="headerlink" title="保持公共API简单"></a>保持公共API简单</h3><p>如果一个函数压根没必要公开，就不要这么做，属性也是一样，同时对方法进行合理的VVDocumenter注释，公开属性以及常量、枚举尽可能的用<code>///&lt;</code>注释，除非特别特别简单的可以省略</p>
<h3 id="关于警告"><a href="#关于警告" class="headerlink" title="关于警告"></a>关于警告</h3><p>代码中遇到警告信息应该尽量解决掉，有一些可能是类型转换警告，有一些是无用的变量，代码永远不会被执行，已废弃的方法等等，有一点<code>代码洁癖</code>、对自己的代码要求严格是一件好事</p>
<h3 id="关于废弃的代码"><a href="#关于废弃的代码" class="headerlink" title="关于废弃的代码"></a>关于废弃的代码</h3><p>项目中遇到废弃的代码、没有用到的类（头文件）、注释掉的代码，除非一定要保留的都要尽量删掉，保留的写好注释，建议用TODO注释，保留的原因以及相关责任人，以便其他人接手不至于懵逼~</p>
<hr>
<h2 id="一些建议"><a href="#一些建议" class="headerlink" title="一些建议"></a>一些建议</h2><h3 id="定义常量时：多用类型常量，少用-define预处理指令"><a href="#定义常量时：多用类型常量，少用-define预处理指令" class="headerlink" title="定义常量时：多用类型常量，少用#define预处理指令"></a>定义常量时：多用类型常量，少用#define预处理指令</h3><p>宏定义没有类型，有被重复定义风险，影响项目编译速度。<br>建议用</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kConst = <span class="string">@"Hello"</span>；</div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">CGFloat</span> kWidth = <span class="number">10.0</span>;</div></pre></td></tr></table></figure>
<p>代替：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#define kConst @<span class="meta-string">"Hello"</span></span></div><div class="line"><span class="meta">#define kWidth 10.0</span></div></pre></td></tr></table></figure>
<p>当定义对外公开的常量的时候，我们一般使用如下定义</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Test.h</span></div><div class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kClassNameconst;</div><div class="line"><span class="comment">//Test.m</span></div><div class="line"><span class="built_in">NSString</span> * <span class="keyword">const</span> kClassNameconst = <span class="string">@"hello"</span>;</div></pre></td></tr></table></figure>
<h3 id="关于枚举"><a href="#关于枚举" class="headerlink" title="关于枚举"></a>关于枚举</h3><p>推荐使用NS_ENUM和NS_OPTIONS定义 </p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>,TestEnum) &#123;</div><div class="line">    MY_INT_CONST = <span class="number">12345</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_OPTIONS</span>(<span class="built_in">NSInteger</span>, SelectType) &#123;</div><div class="line">    SelectA    = <span class="number">0</span>,</div><div class="line">    SelectB    = <span class="number">1</span> &lt;&lt; <span class="number">0</span>,</div><div class="line">    SelectC    = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,</div><div class="line">    SelectD    = <span class="number">1</span> &lt;&lt; <span class="number">2</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在枚举类型的switch语句中不要实现default分支，有一个好处是，当我们给枚举增加成员时，编译器就会提示开发者：<code>switch语句并未处理所有的枚举</code></p>
<h3 id="尽量使用简洁字面量语法"><a href="#尽量使用简洁字面量语法" class="headerlink" title="尽量使用简洁字面量语法"></a>尽量使用简洁字面量语法</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSArray</span> *animals = @[<span class="string">@"dog"</span>, <span class="string">@"pig"</span>, <span class="string">@"you"</span>];</div><div class="line">Dictionary *dict = @&#123;<span class="string">@"animal"</span>:<span class="string">@"tiger"</span>, <span class="string">@"phone"</span>:<span class="string">@"iPhone 6"</span>&#125;;</div><div class="line"></div><div class="line"><span class="built_in">NSString</span> *dog = animals[<span class="number">0</span>];</div><div class="line"><span class="built_in">NSString</span> *iphone = dict[<span class="string">@"phone"</span>];</div></pre></td></tr></table></figure>
<h3 id="属性的strong、copy"><a href="#属性的strong、copy" class="headerlink" title="属性的strong、copy"></a>属性的strong、copy</h3><p>定义可变类型时不要用copy修饰，会留下崩溃隐患</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSMutableArray</span> *mutableArrayOfCopy;   <span class="comment">///&lt; 插入数据时会崩溃</span></div></pre></td></tr></table></figure>
<p>一般NSString 以及NSArray等等不可变类型建议用<code>copy</code>修饰，用<code>strong</code>修饰也没错，不过要确定情景是否真的需要<code>strong</code></p>
<h2 id="结尾："><a href="#结尾：" class="headerlink" title="结尾："></a>结尾：</h2><p>本文对Objective-C编码粗略规范以及一些浅显建议，欢迎大家一起补充完善，共同交流进步，维护增强项目代码的易读性，易扩展性，健壮性等等~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文记录一下Objective-C编程规范以及一些建议，可能后续会有些修改和补充，至于初衷是最近接手的项目中代码”有些”凌乱，所以整理了一篇，有一些来自网上，有一些是我平时的代码风格的吧~&lt;br&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="http://superma.me/all-categories/Objective-C/"/>
    
    
      <category term="编码规范" scheme="http://superma.me/all-tags/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>iOS常量(const)、enum、宏(#define)的使用场景及区别</title>
    <link href="http://superma.me/2016/04/30/post/"/>
    <id>http://superma.me/2016/04/30/post/</id>
    <published>2016-04-29T18:37:54.000Z</published>
    <updated>2017-07-04T15:44:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>前言：本文主要梳理iOS中如何使用常量、enum、宏，以及各自的使用场景。<br><a id="more"></a><br><img src="http://upload-images.jianshu.io/upload_images/1457495-df0b95375604d34b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h2 id="重要的事情首先说："><a href="#重要的事情首先说：" class="headerlink" title="重要的事情首先说："></a>重要的事情首先说：</h2><p>在iOS开发中请尽量多使用const、enum来代替宏定义(#define)；随着项目工程的逐渐增大，过多的宏定义还会影响项目的编译时间</p>
<ul>
<li>宏定义大家应该都不陌生，使用起来非常简单，首先我们先来看一下宏定义跟const的区别：<br>1.宏在编译开始之前就会被替换，而const只是变量进行修饰;<br>2.宏可以定义一些函数方法，const不能<br>3.宏编译时只替换不做检查不报错，也就是说有重复定义问题。而const会编译检查，会报错</li>
</ul>
<hr>
<h2 id="那到底什么时候使用宏，什么时候该使用const？"><a href="#那到底什么时候使用宏，什么时候该使用const？" class="headerlink" title="那到底什么时候使用宏，什么时候该使用const？"></a>那到底什么时候使用宏，什么时候该使用const？</h2><!-- more -->
<ul>
<li>定义<code>不对外公开的常量</code>的时候，我们应该尽量先考虑使用 static 方式声名const来替代使用宏定义。const不能满足的情况再考虑使用宏定义。比如用以下定义：<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kConst = <span class="string">@"Hello"</span>；</div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">CGFloat</span> kWidth = <span class="number">10.0</span>;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>代替：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#define DEFINE @<span class="meta-string">"Hello"</span></span></div><div class="line"><span class="meta">#define WIDTH 10.0</span></div></pre></td></tr></table></figure></p>
<ul>
<li><p>当定义<code>对外公开的常量</code>的时候，我们一般使用如下定义：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Test.h</span></div><div class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> <span class="built_in">CLASSNAMEconst</span>;</div><div class="line"><span class="comment">//Test.m</span></div><div class="line"><span class="built_in">NSString</span> * <span class="keyword">const</span> <span class="built_in">CLASSNAMEconst</span> = <span class="string">@"hello"</span>;</div></pre></td></tr></table></figure>
<ul>
<li>对于整型类型，代替宏定义直接定义整型常量比较好的办法是使用enum，使用enum时推荐使用NS_ENUM和NS_OPTIONS宏。比如用以下定义：<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>,TestEnum) &#123;</div><div class="line">        MY_INT_CONST = <span class="number">12345</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p>代替：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#define MY_INT_CONST 12345</span></div></pre></td></tr></table></figure></p>
<p>NS_OPTIONS定义方式如下：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_OPTIONS</span>(<span class="built_in">NSInteger</span>, SelectType) &#123;</div><div class="line">        SelectA    = <span class="number">0</span>,</div><div class="line">        SelectB    = <span class="number">1</span> &lt;&lt; <span class="number">0</span>,</div><div class="line">        SelectC    = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,</div><div class="line">        SelectD    = <span class="number">1</span> &lt;&lt; <span class="number">2</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<!--readmore-->
<hr>
<h2 id="下面顺便说一下const-的一些使用方式，主要说明这几种写法的区别："><a href="#下面顺便说一下const-的一些使用方式，主要说明这几种写法的区别：" class="headerlink" title="下面顺便说一下const 的一些使用方式，主要说明这几种写法的区别："></a>下面顺便说一下const 的一些使用方式，主要说明这几种写法的区别：</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="built_in">NSString</span> *constString1 = <span class="string">@"I am a const NSString * string"</span>;</div><div class="line"><span class="built_in">NSString</span> <span class="keyword">const</span> *constString2 = <span class="string">@"I am a NSString const * string"</span>;</div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">NSString</span> *staticConstString1 = <span class="string">@"I am a static const NSString * string"</span>;</div><div class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> <span class="keyword">const</span> *staticConstString2 = <span class="string">@"I am a static NSString const * string"</span>;</div><div class="line"><span class="built_in">NSString</span> * <span class="keyword">const</span> stringConst = <span class="string">@"I am a NSString * const string"</span>;</div></pre></td></tr></table></figure>
<hr>
<p>全局变量：<br> <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//全局变量，constString1地址不能修改，constString1值能修改</span></div><div class="line"><span class="keyword">const</span> <span class="built_in">NSString</span> *constString1 = <span class="string">@"I am a const NSString * string"</span>;</div><div class="line"><span class="comment">//意义同上，无区别</span></div><div class="line"><span class="built_in">NSString</span> <span class="keyword">const</span> *constString2 = <span class="string">@"I am a NSString const * string"</span>;</div><div class="line"><span class="comment">// stringConst 地址能修改，stringConst值不能修改</span></div><div class="line"><span class="built_in">NSString</span> * <span class="keyword">const</span> stringConst = <span class="string">@"I am a NSString * const string"</span>;</div></pre></td></tr></table></figure></p>
<p>constString1 跟constString2 无区别.<br>＊左边代表指针本身的类型信息，const表示这个指针指向的这个地址是不可变的<br>＊右边代表指针指向变量的可变性，即指针存储的地址指向的内存单元所存储的变量的可变性</p>
<hr>
<p>局部常量：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//作用域只在本文件中</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">NSString</span> *kstaticConstString1 = <span class="string">@"I am a static const NSString * string"</span>;</div><div class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> <span class="keyword">const</span> *kstaticConstString2 = <span class="string">@"I am a static NSString const * string"</span>;</div><div class="line"><span class="comment">//---------------------------</span></div></pre></td></tr></table></figure></p>
<hr>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>不要用宏定义定义常量，能用const,enum替换的以后就少用宏定义吧。有任何问题或者指点请直接留言，欢迎拍砖~最后感谢你的时间~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前言：本文主要梳理iOS中如何使用常量、enum、宏，以及各自的使用场景。&lt;br&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="http://superma.me/all-categories/Objective-C/"/>
    
    
      <category term="宏" scheme="http://superma.me/all-tags/%E5%AE%8F/"/>
    
      <category term="常量" scheme="http://superma.me/all-tags/%E5%B8%B8%E9%87%8F/"/>
    
  </entry>
  
</feed>
