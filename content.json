{"meta":{"title":"记录学习中的点滴,努力打怪升级-MaLi","subtitle":"记录学习中的点滴","description":"记录学习中的点点滴滴,努力打怪升级~  Objective-C && PHP && Swift && Python","author":"Mali","url":"http://superma.me"},"pages":[{"title":"","date":"2017-05-03T15:33:05.000Z","updated":"2017-05-03T15:33:05.000Z","comments":true,"path":"404.html","permalink":"http://superma.me/404.html","excerpt":"","text":"404 *{margin:0;padding:0;outline:none;font-family:\\5FAE\\8F6F\\96C5\\9ED1,宋体;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;-khtml-user-select:none;user-select:none;cursor:default;font-weight:lighter;} .center{margin:0 auto;} .whole{width:100%;height:100%;line-height:100%;position:fixed;bottom:0;left:0;z-index:-1000;overflow:hidden;} .whole img{width:100%;height:100%;} .mask{width:100%;height:100%;position:absolute;top:0;left:0;background:#000;opacity:0.6;filter:alpha(opacity=60);} .b{width:100%;text-align:center;height:400px;position:absolute;top:50%;margin-top:-230px}.a{width:150px;height:50px;margin-top:30px}.a a{display:block;float:left;width:150px;height:50px;background:#fff;text-align:center;line-height:50px;font-size:18px;border-radius:25px;color:#333}.a a:hover{color:#000;box-shadow:#fff 0 0 20px} p{color:#fff;margin-top:40px;font-size:24px;} #num{margin:0 5px;font-weight:bold;} var num=4; function redirect(){ num--; document.getElementById(\"num\").innerHTML=num; if(num"},{"title":"about","date":"2017-05-09T15:15:37.000Z","updated":"2017-05-09T15:15:37.000Z","comments":true,"path":"about/index.html","permalink":"http://superma.me/about/index.html","excerpt":"","text":""},{"title":"all-archives","date":"2017-06-20T15:43:52.000Z","updated":"2017-06-20T15:43:52.000Z","comments":false,"path":"all-archives/index.html","permalink":"http://superma.me/all-archives/index.html","excerpt":"","text":""},{"title":"all-categories","date":"2017-06-20T15:39:04.000Z","updated":"2017-06-20T15:39:04.000Z","comments":false,"path":"all-categories/index.html","permalink":"http://superma.me/all-categories/index.html","excerpt":"","text":""},{"title":"all-tags","date":"2017-06-20T15:39:52.000Z","updated":"2017-06-20T15:39:52.000Z","comments":false,"path":"all-tags/index.html","permalink":"http://superma.me/all-tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Objective-C编程规范以及建议","slug":"Objective-C编程规范以及建议","date":"2017-07-04T15:36:51.000Z","updated":"2017-07-04T16:28:33.000Z","comments":true,"path":"2017/07/04/Objective-C编程规范以及建议/","link":"","permalink":"http://superma.me/2017/07/04/Objective-C编程规范以及建议/","excerpt":"本文记录一下Objective-C编程规范以及一些建议，可能后续会有些修改和补充，至于初衷是最近接手的项目中代码”有些”凌乱，所以整理了一篇，有一些来自网上，有一些是我平时的代码风格的吧~","text":"本文记录一下Objective-C编程规范以及一些建议，可能后续会有些修改和补充，至于初衷是最近接手的项目中代码”有些”凌乱，所以整理了一篇，有一些来自网上，有一些是我平时的代码风格的吧~ 方法声明和定义-或者+和返回类型之间须使用一个空格，括号要同行并有一个空格 方法应该像这样： 123- (void)doSomethingWithString:(NSString *)theString &#123; ...&#125; 如果函数名字太长，可以用冒号对齐，像这样： 12345- (void)doSomethingWith:(GTMFoo *)theFoo rect:(NSRect)theRect interval:(float)theInterval &#123; ...&#125; 当第一个关键字比其它的短时,要保证下一行至少有4个空格的缩进，对齐关键字，像这样： 12345- (void)short:(GTMFoo *)theFoo longKeyword:(NSRect)theRect evenLongerKeyword:(float)theInterval &#123; ...&#125; 方法调用调用时所有参数应该在同一行： 1[myObject doFooWith:arg1 name:arg2 error:arg3]; 或者每行一个参数，以冒号对齐： 123[myObject doFooWith:arg1 name:arg2 error:arg3]; 方法定义与方法声明一样，当关键字的长度不足以以冒号对齐时，下一行都要以四个空格进行缩进 123[myObj short:arg1 longKeyword:arg2 evenLongerKeyword:arg3]; 不要使用下面的缩进风格： 123456789[myObject doFooWith:arg1 name:arg2 // some lines with &gt;1 arg error:arg3];[myObject doFooWith:arg1 name:arg2 error:arg3];[myObject doFooWith:arg1 name:arg2 // aligning keywords instead of colons error:arg3]; 命名对于易维护的代码而言，命名规则非常重要。Objective-C 的方法名往往十分长，但代码块读起来就像散文一样，不需要太多的代码注释 当编写纯粹的 Objective-C 代码时，我们基本遵守标准的 Objective-C naming rules, 文件名 扩展名 文件分类 .h C/C++/Objective-C 的头文件 .m Objective-C 实现文件 .mm Ojbective-C++ 的实现文件 .cc 纯 C++ 的实现文件 .c 纯C 的实现文件 类名类名（以及类别、协议名）应首字母大写，并以驼峰格式分割单词 Objective-C 方法名方法名应该以小写字母开头，并混合驼峰格式。每个具名参数也应该以小写字母开头方法名应尽量读起来就像句子，这表示你应该选择与方法名连在一起读起来通顺的参数名。（例如，convertPoint:fromRect: 或 replaceCharactersInRange:withString:）。详情参见 Apple’s Guide to Naming Methods第二个参数不要and： 正确: - (instancetype)initWithWidth:(float)width :(float)height; 不好: - (id)initWithWidth:(float)width andHeight:(float)height; 变量名应该使用驼峰命名法，变量名尽量能够代表其自身意思，尽量避免中英文混合命名，中英文混合命名是建议用’_’下划线分割中英文。尽量避免如下命名方式 1234NSDictionary *d0 = [ACGPCacheCenter readFileAtSubDir: HSHomePageSubDirForAD];NSDictionary *d2 = [ACGPCacheCenter readFileAtSubDir: HSHomePageSubDirForZX];NSDictionary *d3 = [ACGPCacheCenter readFileAtSubDir: HSHPSubDirForEntry];NSDictionary *d4 = [ACGPCacheCenter readFileAtSubDir: HSHPSubDirForCopywriting]; 循环以及一些生命周期很短、很浅显易懂的变量可以放开要求，可以使用简单单字母等等变量名 常量名常量名（如宏定义、枚举、静态局部变量等）应该以小写字母 k 开头，使用驼峰格式分隔单词，如：kInvalidHandle，kWritePerm 注释建议注释不要过多，尽量能够做到代码自解释。与其给类型及变量起一个晦涩难懂的名字，再为它写注释，不如直接起一个有意义的名字 关于注释有以下几点建议： .h 文件注释 .h 文件中 interface 前要加VVDocumenter注释，例如下面这个类，根据类名根本不知道哪个模块，做什么的。 123@interface HSHPCopywritingCell : HSBaseCollectionViewCell@end 应改成 123456/** 首页模块-自选股cell */@interface HSHPCopywritingCell : HSBaseCollectionViewCell@end 之后在业务代码中遇到这个类，按住alt键鼠标点击类名就可以查看到类的Description如下： 属性以及成员变量注释属性、成员变量、枚举类型的注释建议用 ///&lt;进行注释 123@property (nonatomic, strong) HSMarketIndexModel *USmodel; ///&lt; 美股指数model@property (nonatomic, strong) HSMarketIndexModel *HKmodel; ///&lt; 港股指数model@property (nonatomic, strong) HSMarketIndexView *indexView; ///&lt; 指数view 同样按住alt键鼠标点击类名也可以查看到类的Description，用/** 美股指数 */ 这种注释方式也可以看到Description，不过属性太多可能会不太美观 代码块注释善用#pragma mark把代码进行分类，#pragma mark没有下划线，#pragma mark -有下划线分割 建议用如下类似代码块组织代码： 1234567891011121314151617181920212223242526272829303132333435363738394041#pragma mark - ================ LifeCycle =================- (void)viewDidLoad &#123; [self configUI]; ...&#125;- (void) viewWillAppear:(BOOL)animated &#123;&#125;...- (void)configUI &#123;&#125;#pragma mark - ================ Public Methods =================#pragma mark ==== 核心公开方法注释- (void)somePublicMethod &#123;&#125;#pragma mark ==== 核心公开方法注释2- (void)somePublicMethod2 &#123;&#125;#pragma mark - ================ Private Methods =================#pragma mark ==== 核心私有方法注释- (void)somePrivateMethod &#123;&#125;#pragma mark - ================ UITableView Delegate =================- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView &#123; &#125;...#pragma mark - ================ Actions =================- (void)someButtonClicked &#123;&#125;#pragma mark - ================ Getter and Setter =================- (void)setModelArray:(NSMutableArray *)modelArray &#123;&#125; 注意:代码块的顺序应该是由重要到不重要，Getter之类的不重要代码块要放在最后，确保别人打开你的类先映入眼帘的是有用的代码 其他保持公共API简单如果一个函数压根没必要公开，就不要这么做，属性也是一样，同时对方法进行合理的VVDocumenter注释，公开属性以及常量、枚举尽可能的用///&lt;注释，除非特别特别简单的可以省略 关于警告代码中遇到警告信息应该尽量解决掉，有一些可能是类型转换警告，有一些是无用的变量，代码永远不会被执行，已废弃的方法等等，有一点代码洁癖、对自己的代码要求严格是一件好事 关于废弃的代码项目中遇到废弃的代码、没有用到的类（头文件）、注释掉的代码，除非一定要保留的都要尽量删掉，保留的写好注释，建议用TODO注释，保留的原因以及相关责任人，以便其他人接手不至于懵逼~ 一些建议定义常量时：多用类型常量，少用#define预处理指令宏定义没有类型，有被重复定义风险，影响项目编译速度。建议用 12static NSString * const kConst = @\"Hello\"；static const CGFloat kWidth = 10.0; 代替： 12#define kConst @\"Hello\"#define kWidth 10.0 当定义对外公开的常量的时候，我们一般使用如下定义 1234//Test.hextern NSString * const kClassNameconst;//Test.mNSString * const kClassNameconst = @\"hello\"; 关于枚举推荐使用NS_ENUM和NS_OPTIONS定义 12345678910typedef NS_ENUM(NSInteger,TestEnum) &#123; MY_INT_CONST = 12345&#125;;typedef NS_OPTIONS(NSInteger, SelectType) &#123; SelectA = 0, SelectB = 1 &lt;&lt; 0, SelectC = 1 &lt;&lt; 1, SelectD = 1 &lt;&lt; 2&#125;; 在枚举类型的switch语句中不要实现default分支，有一个好处是，当我们给枚举增加成员时，编译器就会提示开发者：switch语句并未处理所有的枚举 尽量使用简洁字面量语法12345NSArray *animals = @[@\"dog\", @\"pig\", @\"you\"];Dictionary *dict = @&#123;@\"animal\":@\"tiger\", @\"phone\":@\"iPhone 6\"&#125;;NSString *dog = animals[0];NSString *iphone = dict[@\"phone\"]; 属性的strong、copy定义可变类型时不要用copy修饰，会留下崩溃隐患 1@property (nonatomic, copy) NSMutableArray *mutableArrayOfCopy; ///&lt; 插入数据时会崩溃 一般NSString 以及NSArray等等不可变类型建议用copy修饰，用strong修饰也没错，不过要确定情景是否真的需要strong 结尾：本文对Objective-C编码粗略规范以及一些浅显建议，欢迎大家一起补充完善，共同交流进步，维护增强项目代码的易读性，易扩展性，健壮性等等~","categories":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://superma.me/all-categories/Objective-C/"}],"tags":[]},{"title":"iOS常量(const)、enum、宏(#define)的使用场景及区别","slug":"post","date":"2016-04-29T18:37:54.000Z","updated":"2017-07-04T15:44:49.000Z","comments":true,"path":"2016/04/30/post/","link":"","permalink":"http://superma.me/2016/04/30/post/","excerpt":"前言：本文主要梳理iOS中如何使用常量、enum、宏，以及各自的使用场景。","text":"前言：本文主要梳理iOS中如何使用常量、enum、宏，以及各自的使用场景。 重要的事情首先说：在iOS开发中请尽量多使用const、enum来代替宏定义(#define)；随着项目工程的逐渐增大，过多的宏定义还会影响项目的编译时间 宏定义大家应该都不陌生，使用起来非常简单，首先我们先来看一下宏定义跟const的区别：1.宏在编译开始之前就会被替换，而const只是变量进行修饰;2.宏可以定义一些函数方法，const不能3.宏编译时只替换不做检查不报错，也就是说有重复定义问题。而const会编译检查，会报错 那到底什么时候使用宏，什么时候该使用const？ 定义不对外公开的常量的时候，我们应该尽量先考虑使用 static 方式声名const来替代使用宏定义。const不能满足的情况再考虑使用宏定义。比如用以下定义：12static NSString * const kConst = @\"Hello\"；static const CGFloat kWidth = 10.0; 代替：12#define DEFINE @\"Hello\"#define WIDTH 10.0 当定义对外公开的常量的时候，我们一般使用如下定义： 1234//Test.hextern NSString * const CLASSNAMEconst;//Test.mNSString * const CLASSNAMEconst = @\"hello\"; 对于整型类型，代替宏定义直接定义整型常量比较好的办法是使用enum，使用enum时推荐使用NS_ENUM和NS_OPTIONS宏。比如用以下定义：123typedef NS_ENUM(NSInteger,TestEnum) &#123; MY_INT_CONST = 12345&#125;; 代替：1#define MY_INT_CONST 12345 NS_OPTIONS定义方式如下：123456typedef NS_OPTIONS(NSInteger, SelectType) &#123; SelectA = 0, SelectB = 1 &lt;&lt; 0, SelectC = 1 &lt;&lt; 1, SelectD = 1 &lt;&lt; 2&#125;; 下面顺便说一下const 的一些使用方式，主要说明这几种写法的区别：12345const NSString *constString1 = @\"I am a const NSString * string\";NSString const *constString2 = @\"I am a NSString const * string\";static const NSString *staticConstString1 = @\"I am a static const NSString * string\";static NSString const *staticConstString2 = @\"I am a static NSString const * string\";NSString * const stringConst = @\"I am a NSString * const string\"; 全局变量： 123456//全局变量，constString1地址不能修改，constString1值能修改const NSString *constString1 = @\"I am a const NSString * string\";//意义同上，无区别NSString const *constString2 = @\"I am a NSString const * string\";// stringConst 地址能修改，stringConst值不能修改NSString * const stringConst = @\"I am a NSString * const string\"; constString1 跟constString2 无区别.＊左边代表指针本身的类型信息，const表示这个指针指向的这个地址是不可变的＊右边代表指针指向变量的可变性，即指针存储的地址指向的内存单元所存储的变量的可变性 局部常量：1234//作用域只在本文件中static const NSString *kstaticConstString1 = @\"I am a static const NSString * string\";static NSString const *kstaticConstString2 = @\"I am a static NSString const * string\";//--------------------------- 总结：不要用宏定义定义常量，能用const,enum替换的以后就少用宏定义吧。有任何问题或者指点请直接留言，欢迎拍砖~最后感谢你的时间~","categories":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://superma.me/all-categories/Objective-C/"}],"tags":[{"name":"宏","slug":"宏","permalink":"http://superma.me/all-tags/宏/"},{"name":"常量","slug":"常量","permalink":"http://superma.me/all-tags/常量/"}]}]}